#summary User guide for Reactive and Interactive programming with Reactive4Java.
#labels Featured

<wiki:toc max_depth="3" />

= Introduction =

Without extension methods, function types and yield return, its going to be ugly and cumbersome. But it is worth the effort.


= Fundamentals =

Interactive programming is basically a deferred or lazy computation over {{{Iterable<T>}}} classes. In Java, by using a for-each loop, you may simply iterate over the collections which implement the {{{Iterable<T>}}} interface: {{{List}}}s, {{{Set}}}s, etc.

Frameworks, such as Google Guava, offer some utility method which lets you do some direct or lazy computation, however, their design was not intended for composability. !Reactive4Java offers composable operators for such kind of lazy computation.

Reactive programming, in turn is an inherently asynchronous, and computes only when a message arrives at an observer. Java offers some classes based on the Observer-pattern, but those classes are not uniform and do not compose well. Therefore, a new base interface pair called {{{Observable<T>}}} and {{{Observer<T>}}} has been defined by !Reactive4Java.

They are the [http://en.wikipedia.org/wiki/Dual_(category_theory) dual] of the {{{Iterable<T>}}} and {{{Iterator<T>}}} interface pairs.

An {{{Iterable}}} has an {{{iterator()}}} method which returns an {{{Iterator}}} instance. 

In opposition, the {{{Observable}}} has a {{{register()}}} method which takes an {{{Observer}}} for registration and returns a {{{Closeable}}} to terminate the registration. This approach is easier than a register/unregister method pair, because you don't need to remember the observer or the observable to unregister (e.g., for example in swing, you have to pass in the same ActionListener instance to both addActionListener and removeActionListener of a component: you have to keep references to both around).

The {{{Iterator}}} and {{{Observer}}} are the fundamental working horses of the interactive/reactive programming paradigm. The following table links the well known iterator methods with its equivalents in the observer interface:

|| *Iterator* || *Observer* || *Meaning* ||
|| {{{boolean hasNext()}}} || {{{void finish()}}} || the case when hasNext would return false, indicating there are no more elements ||
|| {{{T next()}}} || {{{void next(T value)}}} || when an element is available; e.g., when hasNext() returns true and you may call next() ||
|| {{{void remove()}}} || - || not applicable ||
|| {{{hasNext()}}} and {{{T next()}}} throws || {{{error(Throwable ex)}}} || indicates an error condition within the stream. Iterator throws only unchecked exceptions. ||

== Lambda expressions, the Java way ==

Unfortunately, Java will not support the lambda expressions probably until version 8. Until then, we are stuck with anonymous inner classes which require you to write a lot of type parameters.

Most !Reactive4Java operators can be customized by such 'lambda' function.

You need to derive your own implementation from {{{Func0<R>}}}, {{{Func1<R, T>}}} and {{{Func2<R, T, U>}}} respectively. They are single method interfaces which have an {{{invoke()}}} method:

{{{
Func1<Integer, Integer> incrementer = new Func1<Integer, Integer>() {
    public Integer invoke(Integer param) {
        return param + 1;
    }
}
}}}

In their definition, the return type parameter is the first listed. This is somewhat different from the C# way of defining the function parameter first and the return type last. *This may change in future, depending on how the Java 8 function type will use its type parameters*.

You might find yourself needing the same functions over and over again, therefore, the [http://reactive4java.googlecode.com/svn/trunk/Reactive4Java/docs/javadoc/hu/akarnokd/reactive4java/base/Functions.html Functions] utility class contains many helper methods to construct or convert some typical Java functions.

  * {{{identity()}}} which returns its argument
  * {{{lessThan()}}}, {{{greaterOrEqual()}}}, etc. to do simple comparisons (e.g., in a for-each like construct)
  * {{{incrementInt()}}} for {{{i++}}} like operations
  * etc.

The second class of helper interfaces are the {{{Action0}}} and {{{Action1<T>}}} respectively. The [http://reactive4java.googlecode.com/svn/trunk/Reactive4Java/docs/javadoc/hu/akarnokd/reactive4java/base/Actions.html Actions] utility class offers some helper methods to create them or convert typical Action-like Java classes.

== Without extension methods ==

Unfortunately, Java does not support extension methods (method definition, which act if they were part of the target class/interface all the times).

The closest feature is the {{{import static Interactive.max}}} way to import static methods of the utility classes.

== Without yield return and async return ==

The compiler of C# 3.5 and 4.0 supports a construct when you can write a simple method with {{{yield return}}} and {{{yield break}}} and the compiler turns them into a proper state-machine of an IEnumerable. Java's compiler does not support this kind of automatism, therefore, the programmer/library developer needs to manually construct {{{Iterable}}}s and track the state between calls. The same is true for asynchronous continuations.

== Without LINQ ==

One feature of C# LINQ is, in concert with the compiler again, to create an expression tree of the lambda expressions used around and submit them along with the evaluation: the 'driver' turns them into proper and possibly optimized SQL statements. Java has no such support and is not known whether one will be created in the future. The !Reactive4Java therefore has no support for the {{{IQueryable}}} and {{{IQbservable}}} like constructs.

= Interactive programming =

The interactive programming is supported through the utility class methods of [http://reactive4java.googlecode.com/svn/trunk/Reactive4Java/docs/javadoc/hu/akarnokd/reactive4java/interactive/Interactive.html Interactive]. Programming in this mentality is close to most Java programmers.

Composing operators means passing around references of {{{Iterable<T>}}}s and the most outer Iterable can be traversed by using the for-each construct:

{{{
for (int i : Interactive.distinctSet(Interactive.concat(Interactive.range(0, 10), Interactive.range(5, 10)))) {
    System.out.println(i);
}
}}}

The interactive framework is mostly a lazy computation. No elements are created or evaluated until the distinctSet object's iterator() is called by the for-each.

Compare this with the classical method of having multiple for-each loops and temporary buffers for the intermediate results.

= Reactive programming =

In contrast to interactive programming, the reactive way is to 'listen' to events coming from outside and do some computation based on them. Depending on the function, this may result in new messages.

The closest equivalent is a blocking {{{take()}}} call on a {{{Queue}}} object. However, this concept holds threading resources until some message comes in.

Reactive programming, in turn, tries to avoid holding resources when no action is required: consider it as a thread pool when new {{{Runnable}}}s are created once a message needs to be processed.

Reactive programming has several concepts associated:

  * the original source of messages,
  * the composition of the operators,
  * the registration,
  * the deregistration and/or cancellation,
  * the error and finish message propagation.

== Hot and cold observables ==

One of the hardest things to comprehend about reactive programming at first is the source of messages or values that fly around.

We distinguish two base kind of observable sequences:

  * *hot observables*: compute only when someone is registered
    * example: a for-each loop generating values once someone registers, everyone will get the same sequence of values
  * *cold observables*: events fly around no matter if there is someone listening
    * example: mouse movement events