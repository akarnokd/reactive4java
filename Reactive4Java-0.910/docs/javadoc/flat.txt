File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Action0.java
------------------------------------------------------------------------

Line: 19

A parameterless action. @author akarnokd

Line: 24

Invoke.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Action1.java
------------------------------------------------------------------------

Line: 19

A simple action-like interface with one parameter. @author akarnokd @param <T> the action parameter

Line: 25

The action body. @param value the value

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Actions.java
------------------------------------------------------------------------

Line: 19

Helper class for Action interfaces. @author akarnokd

Line: 26

Utility class.

Line: 30

A helper action with one parameter which does nothing.

Line: 37

A helper action without parameters which does nothing.

Line: 44

Returns an action which does nothing with its parameter. @param <T> the type of the parameter (irrelevant) @return the action

Line: 53

@return returns an empty action which does nothing.

Line: 57

Wrap the supplied runnable into an action. @param run the original runnable @return the Action0 wrapping the runnable

Line: 70

Wrap the supplied runnable into an action. @param <T> the parameter type @param run the original runnable @return the Action0 wrapping the runnable

Line: 84

Wrap the given action into a runnable instance. @param action the target action @return the wrapper runnable

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\CloseableRunnable.java
----------------------------------------------------------------------------------

Line: 20

A simple combinatorial interface to help implement a runnable and closeable tasks. Closeability for a task is basically a <code>Future.cancel()</code>. @author akarnokd, 2011.02.02.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Func0.java
----------------------------------------------------------------------

Line: 19

A parameterless function interface. @author akarnokd @param <Return> the return type

Line: 25

The function body to invoke. @return the return type

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Func1.java
----------------------------------------------------------------------

Line: 19

The function interface which takes one parameter and returns something. @author akarnokd @param <Return> the return type @param <Param1> the first parameter

Line: 26

The method that gets invoked with a parameter. @param param1 the parameter value @return the return object

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Func2.java
----------------------------------------------------------------------

Line: 19

The function interface which takes two parameter and returns something. @author akarnokd @param <Return> the return type @param <Param1> the first parameter @param <Param2> the second parameter

Line: 27

The method that gets invoked with two parameters. @param param1 the first parameter value @param param2 the second parameter value @return the return object

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Functions.java
--------------------------------------------------------------------------

Line: 29

Helper class with function types. @author akarnokd

Line: 34

Constant function returning always false.

Line: 41

Constant function returning always true.

Line: 48

Constant parameterless function which returns always false.

Line: 55

Constant parameterless function which returns always true.

Line: 62

The identity function which returns its parameter.

Line: 69

Returns a function which always returns false regardless of its parameters. @param <T> the type of the parameter (irrelevant) @return the function which returns always false

Line: 78

Returns a function which always returns true regardless of its parameters. @param <T> the type of the parameter (irrelevant) @return the function which returns always true

Line: 87

Wraps the given Func0 object into a callable instance. @param <T> the return type @param func the function to wrap @return the callable wrapper

Line: 101

Wrap the given two argument function returning an integer as a comparator. @param <T> the type of the elements to compare @param func the function to wrap @return the comparator

Line: 115

Wraps the given Callable function into a Func0 object. @param <T> the return type of the function @param call the original call function @return the Func0 function wrapping the call

Line: 133

Wrap the given comparator function into a function object. @param <T> the type of elements to compare @param comparator the comparator @return the wrapped comparator

Line: 147

Wraps the given atomic boolean and returns its value. @param source the source atomic reference @return the function

Line: 160

Wraps the given atomic integer object and returns its value. @param source the source atomic reference @return the function

Line: 173

Wraps the given atomic integer object and returns its value. @param source the source atomic reference @return the function

Line: 186

Wraps the given atomic reference object and returns its value. @param <T> the type of the contained object @param source the source atomic reference @return the function

Line: 200

Creates a function which returns always the same value. @param <T> the value type to return @param <U> the parameter type, irrelevant @param value the value to return @return the function

Line: 215

Creates a function which returns always the same value. @param <T> the value type to return @param value the value to return @return the function

Line: 229

@return a function which returns param - 1 for Integers.

Line: 240

@return a function which returns param + 1 for Longs.

Line: 251

Returns a function which returns true if its sumbitted parameter value equals to the given constant. @param <T> the value type @param value the value @return the function

Line: 266

Create a function which returns true for submitted values greater or equal than the given value. @param <T> a type which is comparable with itself @param value constant to compare against @return the function

Line: 280

Returns a function which returns true if the function parameter is greater or equal to the constant in respect to the supplied comparator. @param <T> the value type @param value constant to compare against @param comparator the comparator for Ts. @return the function

Line: 296

Create a function which returns true for submitted values greater than the given value. @param <T> a type which is comparable with itself @param value constant to compare against @return the function

Line: 311

Returns a function which returns true if the function parameter is greater than the constant in respect to the supplied comparator. @param <T> the value type @param value constant to compare against @param comparator the comparator for Ts. @return the function

Line: 327

Returns a function which returns its parameter value. @param <T> the type of the object @return the function which returns its parameter as is

Line: 336

Returns a function which increments its parameter by the given amount. Can be used to decrement if value is less than zero @param value the value to increment by @return the function

Line: 350

Returns a function which increments its parameter by the given amount. Can be used to decrement if value is less than zero @param value the value to increment by @return the function

Line: 364

@return a function which returns param + 1 for Integers.

Line: 375

@return a function which returns param + 1 for Longs.

Line: 386

@return a function which returns param + 1 for <code>BigInteger</code>s.

Line: 397

@return a function which returns param - 1 for <code>BigInteger</code>s.

Line: 408

Create a function which returns true for submitted values less or equal than the given value. @param <T> a type which is comparable to itself @param value constant to compare against @return the function

Line: 423

Create a function which returns true for submitted values less or equal than the given value in respect to the supplied comparator. @param <T> a type which is comparable to itself @param value constant to compare against @param comparator the comparator @return the function

Line: 439

Create a function which returns true for submitted values less than the given value. @param <T> a type which is comparable with itself @param value constant to compare against @return the function

Line: 454

Create a function which returns true for submitted values less than the given value in respect to the supplied comparator. @param <T> a type which is comparable to itself @param value constant to compare against @param comparator the comparator @return the function

Line: 470

Returns a function which returns true if its sumbitted parameter value does not equal to the given constant. @param <T> the value type @param value the value @return the function

Line: 485

Creates a function which negates the supplied function's value. @param func the original function @return the wrapped negator function

Line: 498

Utility class.

Line: 500

TODO Auto-generated constructor stub

Line: 502

An empty runnable.

Line: 509

An empty runnable.

Line: 516

Function to sum integers in aggregators.

Line: 523

Function to sum integers in aggregators.

Line: 530

Function to sum integers in aggregators.

Line: 537

Function to sum integers in aggregators.

Line: 544

Function to sum integers in aggregators.

Line: 551

Function to sum integers in aggregators.

Line: 558

@return Function to sum integers in aggregators.

Line: 562

@return Function to sum integers in aggregators.

Line: 566

@return Function to sum integers in aggregators.

Line: 570

@return Function to sum integers in aggregators.

Line: 574

@return Function to sum integers in aggregators.

Line: 578

@return Function to sum integers in aggregators.

Line: 582

A helper function which returns its first parameter.

Line: 589

A helper function which returns its second parameter.

Line: 596

Returns a helper function of two parameters which always returns its first parameter. @param <T> the result and the first parameter type @param <U> the second parameter type, irrelevant @return the function

Line: 606

Returns a helper function of two parameters which always returns its second parameter. @param <T> the result and the second parameter type @param <U> the first parameter type, irrelevant @return the function

Line: 616

Returns a function which returns the greater of its parameters. If only one of the parameters is null, the other parameter is returned. If both parameters are null, null is returned. @param <T> the parameter types, which must be self-comparable @return the function

Line: 637

Returns a function which returns the smaller of its parameters. If only one of the parameters is null, the other parameter is returned. If both parameters are null, null is returned. @param <T> the parameter types, which must be self-comparable @return the function

Line: 658

Returns a function which returns the greater of its parameters in respect to the supplied <code>Comparator</code>. If only one of the parameters is null, the other parameter is returned. If both parameters are null, null is returned. @param <T> the parameter types, which must be self-comparable @param comparator the value comparator @return the function

Line: 680

Returns a function which returns the smaller of its parameters in respect to the supplied <code>Comparator</code>. If only one of the parameters is null, the other parameter is returned. If both parameters are null, null is returned. @param <T> the parameter types, which must be self-comparable @param comparator the value comparator @return the function

Line: 702

Returns a convenience comparator which basically compares objects which implement the <code>Comparable</code> interface. The comparator is null safe in the manner, that nulls are always less than any non-nulls. To have a comparator which places nulls last, use the <code>comparator0()</code> method. @param <T> the element types to compare @return the comparator

Line: 726

Returns a convenience comparator which basically compares objects which implement the <code>Comparable</code> interface. The comparator is null safe in the manner, that nulls are always greater than any non-nulls. To have a comparator which places nulls first, use the <code>comparator()</code> method. @param <T> the element types to compare @return the comparator

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Option.java
-----------------------------------------------------------------------

Line: 19

A class representing a value or nothing. @author akarnokd @param <T> the type of the contained object

Line: 25

/** @return does this option hold a value? */

Line: 25

@return does this option hold a value?

Line: 26

public abstract boolean hasValue();

Line: 27

@return query for the value.

Line: 29

The helper class representing an option holding nothing. @author akarnokd  @param <T> the type of the nothing - not really used but required by the types

Line: 36

Single instance!

Line: 49

A helper class representing an option holding something of T. @author karnokd  @param <T> the type of the contained stuff

Line: 56

The value that is hold by this option.

Line: 58

Construct the some with a value. @param value the value.

Line: 74

Class representing an error option. Calling value on this will throw a RuntimeException which wraps the original exception. @author akarnokd, 2011.01.30. @param <T> the element type

Line: 82

The exception held.

Line: 84

Constructor. @param ex the exception to hold

Line: 102

@return the contained throwable value.

Line: 107

The single instance of the nothingness.

Line: 109

Returns a none of T. @param <T> the type of the T @return the None of T

Line: 118

Create a new Some instance with the supplied value. @param <T> the value type @param value the initial value @return the some object

Line: 127

Create an error instance with the given Throwable. @param <T> the element type, irrelevant @param t the throwable @return the error instance

Line: 136

Returns true if the option is of type Error. @param o the option @return true if the option is of type Error.

Line: 144

Returns true if the option is of type None. @param o the option @return true if the option is of type None.

Line: 152

Returns true if the option is of type Some. @param o the option @return true if the option is of type Some.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\package-info.java
-----------------------------------------------------------------------------

Line: 17

This package contains base classes that help in both reactive and interactive programming.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Ref.java
--------------------------------------------------------------------

Line: 19

A simple reference object holding something that can be changed. Not threadsafe and not ment to be. @author akarnokd @param <T> the type of the contained object

Line: 25

The contained object.

Line: 27

Initializes a null element.

Line: 33

Initializes the ref with the given value. @param value the value

Line: 40

@return retrieve the content.

Line: 44

Set the new content. @param newValue the new value to set

Line: 51

Replace the current contents with the new value and return the old value. @param newValue the new value @return the old value

Line: 61

Construct a new reference of an initial value (type inference helper). @param <U> the type of the value @param value the initial value @return the reference holding the value

Line: 70

Construct a new reference in empty mode. @param <U> the type of the contents @return the reference

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\Scheduler.java
--------------------------------------------------------------------------

Line: 20

An abstract interface for defining minimum scheduling capabilities. @author akarnokd, 2011.02.02.

Line: 26

Schedule for ASAP execution. @param run the runnable task @return the cancel handler

Line: 32

Schedule a single execution of the runnable task with the given delay of nanoseconds. FIXME GWT probably doesn't support the TimeUnit enum @param run the task to run @param delay the initial delay in nanoseconds, implementations might not have the capability to schedule in this resolution @return the cancel handler

Line: 43

Schedule a repeaded execution of the given task with the given initialDelay (in nanoseconds) and betweenDelay (in nanoseconds). The expected semantics from the scheduler is to run the task at a fixed rate (i.e., <code>ExecutorService.scheduleAtFixedRate()</code>). Note: Implementations might not have the capability to schedule nanosecond resolution. @param run the task to run @param initialDelay the initial delay before the first run @param betweenDelay the delay between task runs after the @return the cancel handler

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\base\TooManyElementsException.java
-----------------------------------------------------------------------------------------

Line: 18

Exception for cases when too many elements are contained within a collection or observable. Its the dual of NoSuchElementException. @author akarnokd, 2011.01.30.

Line: 27

A message and cause-less constructo.

Line: 34

Construct the exception by using a message and a cause. @param message the message @param cause the cause

Line: 43

Construct the exception by using a message only. @param message the message

Line: 51

Construct the exception by using a cause only. @param cause the cause

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\interactive\DefaultGroupedIterable.java
----------------------------------------------------------------------------------------------

Line: 22

The default implementation for a grouped iterable which holds the values in a <code>LinkedList</code>. @param <K> the key type @param <V> the value type @author akarnokd, 2011.02.03.

Line: 30

The key.

Line: 32

The group content.

Line: 34

Constructor. @param key the group key

Line: 49

Adds one element to the values. @param value the value

Line: 56

Add the values of the target iterable. @param values the values to add

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\interactive\GroupedIterable.java
---------------------------------------------------------------------------------------

Line: 18

The extension interface to an iterable which holds a group key for its contents. @param <K> the group key type @param <V> the value type @author akarnokd, 2011.02.03.

Line: 26

@return the key of this iterable.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\interactive\Interactives.java
------------------------------------------------------------------------------------

Line: 49

The interactive (i.e., <code>Iterable</code> based) counterparts of the <code>Observables</code> operators. @author akarnokd, 2011.02.02.

Line: 56

Iterates over the given source without using its returned value. This method is useful when the concrete values from the iterator are not needed but the iteration itself implies some side effects. @param source the source iterable to run through

Line: 65

Iterate over the source and submit each value to the given action. Basically, a for-each loop with pluggable action. This method is useful when the concrete values from the iterator are not needed but the iteration itself implies some side effects. @param <T> the element type of the iterable @param source the iterable @param action the action to invoke on with element

Line: 80

Construct a new iterable which will invoke the specified action before the source value gets relayed through it. Can be used to inject side-effects before returning a value. @param <T> the returned element type @param source the source iterable @param action the action to invoke before each next() is returned. @return the new iterable

Line: 114

Creates an iterable which returns only a single element. The returned iterable throws <code>UnsupportedOperationException</code> for its <code>remove()</code> method. @param <T> the element type @param value the value to return @return the new iterable

Line: 127

Return the only element?

Line: 152

Creates an integer iterator which returns numbers from the start position in the count size. @param start the starting value. @param count the number of elements to return, negative count means counting down from the start. @return the iterator.

Line: 183

Creates an long iterator which returns numbers from the start position in the count size. @param start the starting value. @param count the number of elements to return, negative count means counting down from the start. @return the iterator.

Line: 214

Creates an observer with debugging purposes. It prints the submitted values to STDOUT separated by commas and line-broken by 80 characters, the exceptions to STDERR and prints an empty newline when it receives a finish(). @param <T> the value type @return the observer

Line: 224

Creates an observer with debugging purposes. It prints the submitted values to STDOUT, the exceptions to STDERR and prints an empty newline when it receives a finish(). @param <T> the value type @param separator the separator to use between subsequent values @param maxLineLength how many characters to print into each line @return the observer

Line: 235

Indicator for the first element.

Line: 237

The current line length.

Line: 266

Creates an action for debugging purposes. It prints the submitted values to STDOUT with a line break. @param <T> the value type @return the observer

Line: 280

Creates an action for debugging purposes. It prints the submitted values to STDOUT with a line break. @param <T> the value type @param prefix the prefix to use when printing @return the action

Line: 296

Concatenate the given iterable sources one after another in a way, that calling the second <code>iterator()</code> only happens when there is no more element in the first iterator. @param <T> the element type @param first the first iterable @param second the second iterable @return the new iterable

Line: 311

Concatenate the given iterable sources one after another in a way, that calling the second <code>iterator()</code> only happens when there is no more element in the first iterator. @param <T> the element type @param sources the list of iterables to concatenate @return a new iterable

Line: 320

for (I<T> ii : sources) { for (T t : ii) { yield t; } }

Line: 334

The current iterable.

Line: 338

we have more elements in the current iterator

Line: 342

do we have any more iterables?

Line: 375

The common empty iterator.

Line: 390

The common empty iterable.

Line: 397

Returns an empty iterable which will not produce elements. Its <code>hasNext()</code> returns always false, <code>next()</code> throws a <code>NoSuchElementException</code> and <code>remove()</code> throws an <code>IllegalStateException</code>. Note that the <code>Collections.emptyIterable()</code> static method is introduced by Java 7. @param <T> the element type, irrelevant @return the iterable

Line: 410

Returns an iterator which will throw the given <code>Throwable</code> exception when the client invokes <code>next()</code> the first time. Any subsequent <code>next()</code> call will simply throw a <code>NoSuchElementException</code>. Calling <code>remove()</code> will always throw a <code>IllegalStateException</code>. If the given Throwable instance extends a <code>RuntimeException</code>, it is throws as is, but when the throwable is a checked exception, it is wrapped into a <code>RuntimeException</code>. FIXME not sure about next() semantics @param <T> the element type, irrelevant @param t the exception to throw @return the new iterable

Line: 429

First call?

Line: 457

Creates an iterable which filters the source iterable with the given predicate factory function. The predicate returned by the factory receives an index telling how many elements were processed thus far. @param <T> the element type @param source the source iterable @param predicate the predicate @return the new iterable

Line: 469

Creates an iterable which filters the source iterable with the given predicate factory function. The predicate returned by the factory receives an index telling how many elements were processed thus far. Use this construct if you want to use some memorizing predicat function (e.g., filter by subsequent distinct, filter by first occurrences only) which need to be invoked per iterator() basis. @param <T> the element type @param source the source iterable @param predicateFactory the predicate factory which should return a new predicate function for each iterator. @return the new iterable

Line: 481

int i = 0; for (T t : source) { if (predicate(i, t) { yield t; } i++; }

Line: 497

The current element count.

Line: 499

The temporary store for peeked elements.

Line: 535

Creates an iterable which filters the source iterable with the given predicate function. The predicate receives the value and must return a boolean wether to accept that entry. @param <T> the element type @param source the source iterable @param predicate the predicate function @return the new iterable

Line: 552

Creates an iterable which is a transforms the source elements by using the selector function. The function receives the current index and the current element. @param <T> the source element type @param <U> the output element type @param source the source iterable @param selector the selector function @return the new iterable

Line: 568

The current counter.

Line: 589

Creates an iterable which is a transforms the source elements by using the selector function. The function receives the current index and the current element. @param <T> the source element type @param <U> the output element type @param source the source iterable @param selector the selector function @return the new iterable

Line: 607

Creates an iterable which returns a stream of Us for each source Ts. The iterable stream of Us is returned by the supplied selector function. @param <T> the source element type @param <U> the output element type @param source the source @param selector the selector for multiple Us for each T @return the new iterable

Line: 618

for (T t : source) { for (U u : selector(t)) { yield u; } }

Line: 630

The current selected iterator.

Line: 670

Creates an iterable which traverses the source iterable, and based on the key selector, groups values extracted by valueSelector into GroupedIterables, which can be interated over later on. The equivalence of the keys are determined via reference equality and <code>equals()</code> equality. @param <T> the source element type @param <U> the result group element type @param <V> the result group keys @param source the source of Ts @param keySelector the key selector @param valueSelector the value selector @return the new iterable

Line: 735

Returns an iterable which filters its elements by an unique key in a way that when multiple source items produce the same key, only the first one ever seen gets relayed further on. Key equality is computed by reference equality and <code>equals()</code> @param <T> the source element type @param <U> the output element type @param <V> the key element type. @param source the source of Ts @param keySelector the key selector for only-once filtering @param valueSelector the value select for the output of the first key cases @return the new iterable

Line: 770

Returns an iterable which filters its elements based if they vere ever seen before in the current iteration. Value equality is computed by reference equality and <code>equals()</code> @param <T> the source element type @param source the source of Ts @return the new iterable

Line: 781

Creates an iterable which ensures that subsequent values of T are not equal  (reference and equals). @param <T> the element type @param source the source iterable @return the new iterable

Line: 793

Is this the first element?

Line: 795

The last seen element.

Line: 815

Returns an iterable which prefixes the source iterable values by a constant. It is equivalent to <code>concat(singleton(value), source)</code>. @param <T> the lement type @param source the source iterable @param value the value to prefix @return the new iterable.

Line: 827

Utility class.

Line: 829

utility class

Line: 831

A generator function which returns Ts based on the termination condition and the way it computes the next values. This is equivalent to: <code><pre> T value = seed; while (predicate(value)) { yield value; value = next(value); } </pre></code> @param <T> the element type @param seed the initial value @param predicate the predicate to terminate the process @param next the function that computes the next value. @return the new iterable

Line: 877

A generator function which returns Ts based on the termination condition and the way it computes the next values, but the first T to be returned is preceded by an <code>initialDelay</code> amount of wait and each subsequent element is then generated after <code>betweenDelay</code> sleep. The sleeping is blocking the current thread which invokes the hasNext()/next() methods. This is equivalent to: <code><pre> T value = seed; sleep(initialDelay); if (predicate(value)) { yield value; } sleep(betweenDelay); while (predicate(value)) { yield value; value = next(value); sleep(betweenDelay); } </pre></code> @param <T> the element type @param seed the initial value @param predicate the predicate to terminate the process @param next the function that computes the next value. @param initialDelay the initial delay @param betweenDelay the between delay @param unit the time unit for initialDelay and betweenDelay @return the new iterable

Line: 913

Keeps track of whether there should be an initial delay?

Line: 915

Keeps track of whether there should be an initial delay?

Line: 924

FIXME not soure about this

Line: 932

FIXME not soure about this

Line: 960

Transforms the sequence of the source iterable into an option sequence of Option.some(), Option.none() and Option.error() values, depending on what the source's hasNext() and next() produces. The returned iterator will throw an <code>UnsupportedOperationException</code> for its <code>remove()</code> method. @param <T> the source element type @param source the source of at least Ts. @return the new iterable

Line: 975

The peeked value or exception.

Line: 977

The source iterator threw an exception.

Line: 1017

Convert the source materialized elements into normal iterator behavior. The returned iterator will throw an <code>UnsupportedOperationException</code> for its <code>remove()</code> method. @param <T> the source element types @param source the source of T options @return the new iterable

Line: 1062

Merges a bunch of iterable streams where each of the iterable will run by a scheduler and their events are merged together in a single stream. The returned iterator throws an <code>UnsupportedOperationException</code> in its <code>remove()</code> method. @param <T> the element type @param sources the iterable of source iterables. @param scheduler the scheduler for running each inner iterable in parallel @return the new iterable

Line: 1106

Are we broken?

Line: 1122

FIXME not sure about this

Line: 1153

Merges a bunch of iterable streams where each of the iterable will run by a scheduler and their events are merged together in a single stream. The returned iterator throws an <code>UnsupportedOperationException</code> in its <code>remove()</code> method. @param <T> the element type @param sources the iterable of source iterables. @return the new iterable

Line: 1164

Invoke the <code>close()</code> method on the closeable instance and throw away any <code>IOException</code> it might raise. @param c the closeable instance, <code>null</code>s are simply ignored

Line: 1178

Merges two iterable streams. @param <T> the element type @param first the first iterable @param second the second iterable @return the resulting stream of Ts

Line: 1191

Creates an iterator which attempts to re-iterate the source if it threw an exception. <code><pre> while (count-- > 0) { try { for (T t : source) { yield t; } break; } catch (Throwable t) { if (count <= 0) { throw t; } } } </pre></code> @param <T> the source type @param source the source of Ts @param count the number of retry attempts @return the new iterable

Line: 1217

The retry count.

Line: 1219

The peek store.

Line: 1221

The current iterator.

Line: 1260

Counts the elements of the iterable source. @param <T> the element type @param source the source iterable @return the new iterable

Line: 1272

The peek ahead container.

Line: 1274

Computation already done.

Line: 1314

Creates an iterable which if iterates over the sourec and encounters an exception, the iteration is continued on the new iterable returned by the handler function. @param <T> the element type @param source the source iterable. @param handler the exception handler. @return the new iterable

Line: 1327

The current iterator.

Line: 1329

The peek ahead container.

Line: 1365

Creates an iterable which if iterates over the sourec and encounters an exception, it simply stops the iteration, consuming the exception. @param <T> the element type @param source the source iterable. @return the new iterable

Line: 1375

Creates an iterable which resumes with the next iterable from the sources when one throws an exception. @param <T> the source element type @param sources the list of sources to try one after another @return the new iterable

Line: 1388

The current iterator.

Line: 1390

The peek ahead container.

Line: 1432

Creates an iterable which resumes with the next iterable from the sources when one throws an exception. @param <T> the source element type @param first the first source @param second the second source @return the new iterable

Line: 1445

Creates an iterable which resumes with the next iterable from the sources when one throws an exception or completes normally. @param <T> the source element type @param sources the list of sources to try one after another @return the new iterable

Line: 1458

The current iterator.

Line: 1460

The peek ahead container.

Line: 1508

Creates an iterable which resumes with the next iterable from the sources when one throws an exception. @param <T> the source element type @param first the first source @param second the second source @return the new iterable

Line: 1521

Generates an iterable which acts like a running sum when iterating over the source iterable, e.g., For each element in T, it computes a value by using the current aggregation value and returns it. The first call to the aggregator function will receive a zero for its first argument. @param <T> the source element type @param <U> the destination element type @param source the source of Ts @param seed the initial value of the running aggregation @param aggregator the function which takes the current running aggregation value, the current element and produces a new aggregation value. @return the new iterable

Line: 1538

The current value.

Line: 1560

Generates an iterable which acts like a running sum when iterating over the source iterable, e.g., For each element in T, it computes a value by using the current aggregation value and returns it. The first call to the aggregator function will receive a zero for its first argument. @param <T> the source element type @param <U> the destination element type @param source the source of Ts @param aggregator the function which takes the current running aggregation value, the current element and produces a new aggregation value. @return the new iterable

Line: 1573

Returns the last element of the iterable or throws a <code>NoSuchElementException</code> if the iterable is empty. @param <T> the source element type @param source the source of Ts @return the last value

Line: 1590

A linked buffer, which can be only filled and queried. @author akarnokd, 2011.02.03. @param <T> the element type

Line: 1596

The node.

Line: 1598

The element value.

Line: 1600

The next node.

Line: 1603

The head pointer.

Line: 1605

The tail pointer.

Line: 1607

The size.

Line: 1609

Add a new value. @param value the new value

Line: 1621

The returned iterable ensures that the source iterable is only traversed once, regardless of how many iterator attaches to it and each iterator see only the values. Note: the name is not a misspelling, see <a href='http://en.wikipedia.org/wiki/Memoization'>Memoization</a>. @param <T> the source element type @param source the source of Ts @return the new iterable

Line: 1624

en.wikipedia.org/wiki/Memoization'>Memoization</a>.

Line: 1636

The element count.

Line: 1638

The current node pointer.

Line: 1673

The returned iterable ensures that the source iterable is only traversed once, regardless of how many iterator attaches to it and each iterator see only the values. @param <T> the source element type @param <U> the return types @param source the source of Ts @param func invoke the function on the buffering iterable and return an iterator over it. @return the new iterable

Line: 1686

The returned iterable ensures that the source iterable is only traversed once, regardless of how many iterator attaches to it and each iterator see only the same cached values. @param <T> the source element type @param <U> the return types @param source the source of Ts @param func invoke the function on the buffering iterable and return an iterator over it. @param initial the initial value to append to the output stream @return the new iterable

Line: 1700

A simple circular buffer with absolute indices. @author akarnokd, 2011.02.04. @param <T> the contained element type

Line: 1706

The buffer.

Line: 1708

The head pointer.

Line: 1710

The tail pointer.

Line: 1712

Construct a new circular buffer. @param size the buffer size

Line: 1719

@return is the buffer empty?

Line: 1723

Add a new value to the buffer. If the buffer would overflow, it automatically removes the current head element. @param value the value

Line: 1734

Retrieve a buffer element based on an absolute index. @param index the absolute index @return the value

Line: 1749

@return the current size of the buffer.

Line: 1754

Enumerates the source iterable once and caches its results. Any iterator party will basically drain this cache, e.g., reiterating over this iterable will produce no results. Note: the name is not a misspelling, see <a href='http://en.wikipedia.org/wiki/Memoization'>Memoization</a>. FIXME not sure about the buffer sizes. @param <T> the source element type @param source the source of Ts @param bufferSize the size of the buffering @return the new iterable

Line: 1758

en.wikipedia.org/wiki/Memoization'>Memoization</a>.

Line: 1770

The source iterator.

Line: 1772

The ring buffer of the memory.

Line: 1812

The returned iterable ensures that the source iterable is only traversed once, regardless of how many iterator attaches to it and each iterator may only see one source element. @param <T> the source element type @param <U> the return types @param source the source of Ts @param func invoke the function on the buffering iterable and return an iterator over it. @return the new iterable

Line: 1825

The returned iterable ensures that the source iterable is only traversed once, regardless of how many iterator attaches to it and each iterator see only the some cached values. @param <T> the source element type @param <U> the return types @param source the source of Ts @param func invoke the function on the buffering iterable and return an iterator over it. @param bufferSize the buffer size @return the new iterable

Line: 1840

Determines if the given source has any elements at all. @param <T> the source element type, irrelevant here @param source the source of Ts @return the new iterable with a single true or false

Line: 1851

The source's iterator.

Line: 1854

Query once.

Line: 1884

Tests if there is any element of the source that satisfies the given predicate function. @param <T> the source element type @param source the source of Ts @param predicate the predicate tester function @return the new iterable

Line: 1894

Creates an iterable which traverses the source iterable and maintains a running sum value based on the <code>sum</code> function parameter. Once the source is depleted, it applies the <code>divide</code> function and returns its result. This operator is a general base for averaging (where {@code sum(u, t) => u + t}, {@code divide(u, index) => u / index}), summing (where {@code sum(u, t) => u + t}, and {@code divide(u, index) => u)}), minimum, maximum, etc. If the traversal of the source fails due an exception, that exception is reflected on the {@code next()} call of the returned iterator. @param <T> the source element type @param <U> the itermediate aggregation type @param <V> the resulting aggregation type @param source the source of Ts @param sum the function which takes the current itermediate value, the current source value and should produce a new intermediate value. for the first element of T, the U parameter will receive null @param divide the function which takes the last intermediate value and a total count of Ts seen and should return the final aggregation value. @return the new iterable

Line: 1920

The source iterator.

Line: 1922

The single result container.

Line: 1924

We have finished the aggregation.

Line: 1966

Returns an iterable which averages the source Integer values. @param source the source of Integer values @return the new iterable

Line: 1987

Returns an iterable which averages the source Integer values. @param source the source of Integer values @return the new iterable

Line: 2008

Returns an iterable which averages the source Double values. @param source the source of Double values @return the new iterable

Line: 2029

Returns an iterable which averages the source Float values. @param source the source of Float values @return the new iterable

Line: 2050

Returns an iterable which averages the source BigInteger values. @param source the source of BigInteger values @return the new iterable

Line: 2071

Returns an iterable which averages the source BigDecimal values. @param source the source of BigDecimal values @return the new iterable

Line: 2092

Sum the source of Integer values and returns it as a single element. @param source the source @return the new iterable

Line: 2102

Sum the source of Long values and returns it as a single element. @param source the source @return the new iterable

Line: 2112

Sum the source of Float values and returns it as a single element. @param source the source @return the new iterable

Line: 2122

Sum the source of Double values and returns it as a single element. @param source the source @return the new iterable

Line: 2132

Sum the source of Integer values and return it as a single element. @param source the source @return the new iterable

Line: 2142

Sum the source of Integer values and return it as a single element. @param source the source @return the new iterable

Line: 2152

Concatenates the source strings one after another and uses the given separator. @param source the source @param separator the separator to use @return the new iterable

Line: 2180

Returns the minimum value of the given iterable source. @param <T> the element type, which must be self comparable @param source the source elements @return the new iterable

Line: 2189

Returns the maximum value of the given iterable source. @param <T> the element type, which must be self comparable @param source the source elements @return the new iterable

Line: 2198

Returns the minimum value of the given iterable source in respect to the supplied comparator. @param <T> the element type, which must be self comparable @param source the source elements @param comparator the comparator to use @return the new iterable

Line: 2208

Returns the maximum value of the given iterable source in respect to the supplied comparator. @param <T> the element type, which must be self comparable @param source the source elements @param comparator the comparator to use @return the new iterable

Line: 2218

Returns an iterator which will produce a single List of the minimum values encountered in the source stream based on the supplied key selector and comparator. @param <T> the source element type @param <U> the key type @param source the source of Ts @param keySelector the selector for keys @param keyComparator the key comparator @param max should the computation return the minimums or the maximums @return the new iterable

Line: 2235

The source iterator.

Line: 2237

The single result container.

Line: 2239

We have finished the aggregation.

Line: 2286

Returns an iterator which will produce a single List of the minimum values encountered in the source stream based on the supplied key selector and comparator. @param <T> the source element type @param <U> the key type @param source the source of Ts @param keySelector the selector for keys @param keyComparator the key comparator @return the new iterable

Line: 2300

Returns an iterator which will produce a single List of the minimum values encountered in the source stream based on the supplied key selector and comparator. @param <T> the source element type @param <U> the key type @param source the source of Ts @param keySelector the selector for keys @param keyComparator the key comparator @return the new iterable

Line: 2314

Returns an iterator which will produce a single List of the maximum values encountered in the source stream based on the supplied key selector. @param <T> the source element type @param <U> the key type, which must be self-comparable @param source the source of Ts @param keySelector the selector for keys @return the new iterable

Line: 2327

Returns an iterator which will produce a single List of the minimum values encountered in the source stream based on the supplied key selector. @param <T> the source element type @param <U> the key type, which must be self-comparable @param source the source of Ts @param keySelector the selector for keys @return the new iterable

Line: 2340

Returns an iterator which will produce a single List of the maximum values encountered in the source stream based on the supplied key selector. @param <T> the source element type, which must be self comparable @param source the source of Ts @return the new iterable

Line: 2350

Returns an iterator which will produce a single List of the minimum values encountered in the source stream based on the supplied key selector. @param <T> the source element type, which must be self comparable @param source the source of Ts @return the new iterable

Line: 2360

Returns an iterator which will produce a single List of the minimum values encountered in the source stream based on the supplied comparator. @param <T> the source element type @param source the source of Ts @param comparator the key comparator @return the new iterable

Line: 2371

Returns an iterator which will produce a single List of the maximum values encountered in the source stream based on the supplied comparator. @param <T> the source element type @param source the source of Ts @param comparator the key comparator @return the new iterable

Line: 2383

@return the current default pool used by the Observables methods

Line: 2389

Replace the current default scheduler with the specified  new scheduler. This method is threadsafe @param newScheduler the new scheduler @return the current scheduler

Line: 2401

The common observable pool where the Observer methods get invoked by default.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\interactive\package-info.java
------------------------------------------------------------------------------------

Line: 17

This package contains the <b>Interactives</b> main utility class for the interactive programming side of the library, accompanied by some helper classes.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\interactive\SingleContainer.java
---------------------------------------------------------------------------------------

Line: 19

Helper class that stores a single element. The caller may add a new element only when the peeker is empty and the caller may take the contained element if there is one. Use the <code>isEmpty()</code> to check for the status The add and take methods might throw <code>IllegalStateException</code>, which should indicate a library bug. Typically used by the Interactives methods to help them conform with the Iterable contract, e.g., <code>hasNext()</code> is idempotent, but <code>next()</code> might be called without <code>hasNext()</code> to be called at all. The container is not threadsafe. @author akarnokd, 2011.02.03. @param <T> the contained element type

Line: 32

The currently stored value.

Line: 34

The state.

Line: 36

Add a new value. Might throw an <code>IllegalStateException</code> when the container already has a value. @param value the new value

Line: 48

@return the content or throws an <code>IllegalStateException</code> when the container is empty.

Line: 60

@return true if there is nothing contained

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\CloseableObserver.java
--------------------------------------------------------------------------------------

Line: 21

A simple helper interface for a closable and observable instance. @author akarnokd, 2011.02.02. @param <T> the element type to observe

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\DefaultObservable.java
--------------------------------------------------------------------------------------

Line: 27

An observable + observer implementation which keeps track of the registered observers and common methods which dispach events to all registered observers. The implementation is thread safe: all default methods may be invoked from any thread. Could be used as a default implementation to convert between Observable and other event-listener type pattern. deregistering them all. The observer keeps track of the registered observer count and when it reaches zero again, the last deregister will invoke the <code>close()</code> method. Override <code>close()</code> method if you need some resource cleanup. Note that this may happen on any thread. @author akarnokd, 2011.01.29. @param <T> the element type of the observable.

Line: 40

Atomically keeps track of the registered/deregistered observer count.

Line: 42

The map of the active observers.

Line: 44

Unregister all on error?

Line: 46

Unregister all on error?

Line: 48

Default constructor. All observers will be unregistered upon error() or finish().

Line: 54

Constructor with the option to set the unregistration policies. @param unregisterOnFinish unregister all observers on a finish() call? @param unregisterOnError unregister all observers on an error() call?

Line: 100

FIXME allow multiple registrations for the same observer instance?!

Line: 111

Unregister the observer belonging to the given handler. A handler can only be unregistered once @param handler the observer's handler

Line: 125

no operation

Line: 127

@return Returns the current observer count.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\DefaultObserver.java
------------------------------------------------------------------------------------

Line: 19

A wrapper implementation for observer which is able to unregister from the Observable. Use the registerWith() and unregister() methods instead of adding this to a register() call. @author akarnokd, 2011.01.29. @param <T> the element type to observe

Line: 28

no op

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\DefaultRunnable.java
------------------------------------------------------------------------------------

Line: 19

The runnable instance which is aware of its scheduler's registration. FIXME concurrency questions with the storage of the current future @author akarnokd, 2011.01.29.

Line: 27

no op

Line: 31

no op

Line: 35

no op

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\DefaultRunnableObserver.java
--------------------------------------------------------------------------------------------

Line: 28

A composite scheduler and observer class for cases when the observation is entangled with some timed schedule operation and they need to communicate with each other and deregister together. @author akarnokd, 2011.01.30. @param <T> the observed type

Line: 37

The future holding the reference to the scheduled part.

Line: 39

The handler returned by the registration.

Line: 41

/** The lock that helps to ensure the next(), finish() and error() are never overlapping. */

Line: 41

The lock that helps to ensure the next(), finish() and error() are never overlapping.

Line: 42

private final Lock lock = new ReentrantLock(true);

Line: 43

/** Helper indicator that this observer may process its events: closed ones will ignore any further events. */

Line: 43

Helper indicator that this observer may process its events: closed ones will ignore any further events.

Line: 44

protected final AtomicBoolean live = new AtomicBoolean(true);

Line: 45

Schedules this instance on the given pool with the defined delay. If this instance has an associated future, that instance gets cancelled @param pool the scheduler pool @param delay the delay @param unit the time unit of the delay

Line: 57

Replace the future registration with the current contents and cancel the old one if there was any. @param f the new future @return the new future

Line: 70

Replace the current contents of the handler registration with the new one and close the old one if there was any. @param c the new Closeable @return the new Closeable

Line: 83

Registers this instance on the given pool as a repeatable task which gets repeated at a fixed rate after an initial delay. @param pool the target scheduler pool @param initialDelay the initial schedule delay @param delay the delay between runs @param unit the time unit of the initialDelay and delay parameters

Line: 96

Submit this task to the given executor service without any scheduling requirements. If this instance has an associated future, that instance gets cancelled @param pool the target executor service

Line: 107

Register with the given observable and store the closeable handle of this registration. If this was registered to another observable, that registration is unregistered. @param observable the target observable

Line: 114

FIXME assignment delay???

Line: 116

Deregisters the current instance from the associated observer without affecting the scheduler part's registration. If you need to deregister both, use the close() method instead.

Line: 124

Cancel the scheduler part of this instance without cancelling the observable registration. If you need to deregister both, use the close() method instead.

Line: 132

@return the convenience method for Thread.currentThread().isInterrupted().

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\GroupedObservable.java
--------------------------------------------------------------------------------------

Line: 19

An observable which provides a key as its group identity. @author akarnokd, 2011.01.29. @param <Key> the key type @param <Value> the value type

Line: 26

@return the key of this group.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\Observable.java
-------------------------------------------------------------------------------

Line: 22

Defines a provider for a push based value streaming. Based on Rx. @author akarnokd @param <T> the type of the values to send

Line: 28

Registers an observer for the notification of Ts. @param observer the observer of Ts or any supertype of it @return the way of deregister the observer from this provider

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\Observables.java
--------------------------------------------------------------------------------

Line: 59

Utility class to manage observable interfaces. Guidances were taken from <ul> <li>http://theburningmonk.com/tags/rx/</li> <li>http://blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx</li> <li>http://rxwiki.wikidot.com/101samples#toc3</li> </ul>  @author akarnokd, 2011.01.26

Line: 63

theburningmonk.com/tags/rx/</li>

Line: 64

blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx</li>

Line: 65

rxwiki.wikidot.com/101samples#toc3</li>

Line: 73

A variant of the registering observable which stores a group key. @author akarnokd, 2011.01.29. @param <Key> the type of the key @param <Value> the value type

Line: 80

The group key.

Line: 82

Constructor. @param key the group key

Line: 94

The diagnostic states of the current runnable.

Line: 96

The common observable pool where the Observer methods get invoked by default.

Line: 98

Creates an observable which accumultates the given source and submits each intermediate results to its subscribers. Example:<br> <code>range(0, 5).accumulate((x, y) => x + y)</code> produces a sequence of [0, 1, 3, 6, 10];<br> basically the first event (0) is just relayed and then every pair of values are simply added together and relayed @param <T> the element type to accumulate @param source the source of the accumulation @param accumulator the accumulator which takest the current accumulation value and the current observed value and returns a new accumulated value @return the observable

Line: 114

The current accumulated value.

Line: 116

Are we waiting for the first value?

Line: 141

Creates an observable which accumultates the given source and submits each intermediate results to its subscribers. Example:<br> <code>range(0, 5).accumulate(1, (x, y) => x + y)</code> produces a sequence of [1, 2, 4, 7, 11];<br> basically the accumulation starts from zero and the first value (0) that comes in is simply added @param <T> the element type to accumulate @param source the source of the accumulation @param seed the initial value of the accumulation @param accumulator the accumulator which takest the current accumulation value and the current observed value and returns a new accumulated value @return the observable

Line: 158

The current accumulated value.

Line: 177

Creates an observable which accumultates the given source and submits each intermediate results to its subscribers. Example:<br> <code>range(1, 5).accumulate0(1, (x, y) => x + y)</code> produces a sequence of [1, 2, 4, 7, 11, 16];<br> basically, it submits the seed value (1) and computes the current aggregate with the current value(1). @param <T> the element type to accumulate @param source the source of the accumulation @param seed the initial value of the accumulation @param accumulator the accumulator which takest the current accumulation value and the current observed value and returns a new accumulated value @return the observable

Line: 195

The current accumulated value.

Line: 197

Are we waiting for the first value?

Line: 222

Returns an observable which provides a TimeInterval of Ts which records the elapsed time between successive elements. The time interval is evaluated using the System.nanoTime() differences as nanoseconds The first element contains the time elapsed since the registration occurred. @param <T> the time source @param source the source of Ts @return the new observable

Line: 259

Wrap the values within a observable to a timestamped value having always the System.currentTimeMillis() value. @param <T> the element type @param source the source which has its elements in a timestamped way. @return the raw observables of Ts

Line: 269

Apply an accumulator function over the observable source and submit the accumulated value to the returned observable. @param <T> the element type @param source the source observable @param accumulator the accumulator function where the first parameter is the current accumulated value and the second is the now received value. @return the observable for the result of the accumulation

Line: 281

The current aggregation result.

Line: 283

How many items did we get

Line: 291

FIXME not sure about this

Line: 310

Apply an accumulator function over the observable source and submit the accumulated value to the returned observable. @param <T> the input element type @param <U> the ouput element type @param source the source observable @param seed the initial value of the accumulator @param accumulator the accumulator function where the first parameter is the current accumulated value and the second is the now received value. @return the observable for the result of the accumulation

Line: 324

The current aggregation result.

Line: 343

Signals a single true or false if all elements of the observable matches the predicate. It may return early with a result of false if the predicate simply does not match the current element. For a true result, it waits for all elements of the source observable. @param <T> the type of the source data @param source the source observable @param predicate the predicate to setisfy @return the observable resulting in a single result

Line: 357

Indicate if we returned early.

Line: 383

Channels the values of the first observable who fires first from the given set of observables. E.g., <code>O3 = Amb(O1, O2)</code> if O1 starts to submit events first, O3 will relay these events and events of O2 will be completely ignored @param <T> the type of the observed element @param sources the iterable list of source observables. @return the observable which reacted first

Line: 404

We won the race.

Line: 406

Cancel everyone else.

Line: 414

@return Check if we won the race.

Line: 458

Signals a single true if the source observable contains any element. It might return early for a non-empty source but waits for the entire observable to return false. @param <T> the element type @param source the source @return the observable

Line: 468

Signals a single TRUE if the source signals any next() and the value matches the predicate before it signals a finish(). It signals a false otherwise. @param <T> the source element type. @param source the source observable @param predicate the predicate to test the values @return the observable.

Line: 509

Convert the given observable instance into a classical iterable instance. @param <T> the element type to iterate @param observable the original observable @return the iterable

Line: 518

Convert the given observable instance into a classical iterable instance. @param <T> the element type to iterate @param observable the original observable @param pool the pool where to await elements from the observable. @return the iterable

Line: 551

Close the association if there is no more elements.

Line: 553

The peek value due hasNext.

Line: 555

Indicator if there was a hasNext() call before the next() call.

Line: 557

Close the helper observer.

Line: 622

Wrap the iterable object into an observable and use the default pool when generating the iterator sequence. @param <T> the type of the values @param iterable the iterable instance @return the observable

Line: 632

Wrap the iterable object into an observable and use the given pool when generating the iterator sequence. @param <T> the type of the values @param iterable the iterable instance @param pool the thread pool where to generate the events from the iterable @return the observable

Line: 666

Creates an observer which calls the given functions on its similarly named methods. @param <T> the value type to receive @param next the action to invoke on next() @param error the action to invoke on error() @param finish the action to invoke on finish() @return the observer

Line: 693

Wraps the given action as an observable which reacts only to <code>next()</code> events. @param <T> the type of the values @param action the action to wrap @return the observer wrapping the action

Line: 703

ignored

Line: 707

ignored

Line: 715

Computes the average of the source Ts by applying a sum function and applying the divide function when the source finishes, sending the average to the output. @param <T> the type of the values @param <U> the type of the intermediate sum value @param <V> the type of the final average value @param source the source of BigDecimals to aggregate. @param sum the function which sums the input Ts. The first received T will be acompanied by a null U. @param divide the function which perform the final division based on the number of elements @return the observable for the average value

Line: 731

The number of values.

Line: 733

The sum of the values thus far.

Line: 758

Computes and signals the average value of the BigDecimal source. The source may not send nulls. @param source the source of BigDecimals to aggregate. @return the observable for the average value

Line: 783

Computes and signals the average value of the BigInteger source. The source may not send nulls. @param source the source of BigIntegers to aggregate. @return the observable for the average value

Line: 808

Computes and signals the average value of the Double source. The source may not send nulls. @param source the source of Doubles to aggregate. @return the observable for the average value

Line: 833

Computes and signals the average value of the Float source. The source may not send nulls. @param source the source of Floats to aggregate. @return the observable for the average value

Line: 858

Computes and signals the average value of the integer source. The source may not send nulls. @param source the source of integers to aggregate. @return the observable for the average value

Line: 883

Computes and signals the average value of the Long source. The source may not send nulls. @param source the source of longs to aggregate. @return the observable for the average value

Line: 908

Buffer the nodes as they become available and send them out in bufferSize chunks. The observers return a new and modifiable list of T on every next() call. @param <T> the type of the elements @param source the source observable @param bufferSize the target buffer size @return the observable of the list

Line: 922

The current buffer.

Line: 954

Buffer the Ts of the source until the buffer reaches its capacity or the current time unit runs out. Might result in empty list of Ts and might complete early when the source finishes before the time runs out. It uses the default scheduler pool. @param <T> the type of the values @param source the source observable @param bufferSize the allowed buffer size @param time the time value to wait betveen buffer fills @param unit the time unit @return the observable of list of Ts

Line: 969

Buffer the Ts of the source until the buffer reaches its capacity or the current time unit runs out. Might result in empty list of Ts and might complete early when the source finishes before the time runs out. @param <T> the type of the values @param source the source observable @param bufferSize the allowed buffer size @param time the time value to wait betveen buffer fills @param unit the time unit @param pool the pool where to schedule the buffer splits @return the observable of list of Ts

Line: 1004

The buffer to fill in.

Line: 1031

Buffers the source observable Ts into a list of Ts periodically and submits them to the returned observable. Each next() invocation contains a new and modifiable list of Ts. The signaled List of Ts might be empty if no Ts appeared from the original source within the current timespan. The last T of the original source triggers an early submission to the output. The scheduling is done on the default Scheduler. @param <T> the type of elements to observe @param source the source of Ts. @param time the time value to split the buffer contents. @param unit the time unit of the time @return the observable of list of Ts

Line: 1046

Buffers the source observable Ts into a list of Ts periodically and submits them to the returned observable. Each next() invocation contains a new and modifiable list of Ts. The signaled List of Ts might be empty if no Ts appeared from the original source within the current timespan. The last T of the original source triggers an early submission to the output. @param <T> the type of elements to observe @param source the source of Ts. @param time the time value to split the buffer contents. @param unit the time unit of the time @param pool the scheduled execution pool to use @return the observable of list of Ts

Line: 1079

The buffer to fill in.

Line: 1098

Wraps two or more closeables into one closeable. <code>IOException</code>s thrown from the closeables are suppressed. @param c0 the first closeable @param c1 the second closeable @param closeables the rest of the closeables @return the composite closeable

Line: 1130

Creates a composite closeable from the array of closeables. <code>IOException</code>s thrown from the closeables are suppressed. @param closeables the closeables array @return the composite closeable

Line: 1150

Concatenates the source observables in a way that when the first finish(), the second gets registered and continued, and so on. FIXME not sure how it should handle closability @param <T> the type of the values to observe @param sources the source list of subsequent observables @return the concatenated observable

Line: 1195

Concatenate two observables in a way when the first finish() the second is registered and continued with. @param <T> the type of the elements @param first the first observable @param second the second observable @return the concatenated observable

Line: 1209

Signals a single TRUE if the source observable signals a value equals() with the source value. Both the source and the test value might be null. The signal goes after the first encounter of the given value. @param <T> the type of the observed values @param source the source observable @param value the value to look for @return the observer for contains

Line: 1226

Counts the number of elements in the observable source. @param <T> the element type @param source the source observable @return the count signal

Line: 1236

FIXME sequence guaranties?

Line: 1238

The counter.

Line: 1260

Counts the number of elements in the observable source as a long. @param <T> the element type @param source the source observable @return the count signal

Line: 1270

FIXME sequence guaranties?

Line: 1272

The counter.

Line: 1294

Create an observable instance by submitting a function which takes responsibility for registering observers. @param <T> the type of the value to observe @param subscribe the function to manage new subscriptions @return the observable instance

Line: 1315

Create an observable instance by submitting a function which takes responsibility for registering observers and returns a custom Closeable to terminate the registration. @param <T> the type of the value to observe @param subscribe the function to manage new subscriptions @return the observable instance

Line: 1330

Constructs an observer which logs errors in case next(), finish() or error() is called and the observer is not in running state anymore due an earlier finish() or error() call. @param <T> the element type. @param source the source observable @return the augmented observable

Line: 1373

The returned observable invokes the <code>observableFactory</code> whenever an observer tries to subscribe to it. @param <T> the type of elements to observer @param observableFactory the factory which is responsivle to create a source observable. @return the result observable

Line: 1388

Delays the propagation of events of the source by the given amount. It uses the pool for the scheduled waits. The delay preserves the relative time difference between subsequent notifiactions. It uses the default scheduler pool when submitting the delayed values @param <T> the type of elements @param source the source of Ts @param time the time value @param unit the time unit @return the delayed observable of Ts

Line: 1401

Delays the propagation of events of the source by the given amount. It uses the pool for the scheduled waits. The delay preserves the relative time difference between subsequent notifiactions @param <T> the type of elements @param source the source of Ts @param time the time value @param unit the time unit @param pool the pool to use for scheduling @return the delayed observable of Ts

Line: 1478

Returns an observable which fires next() events only when the subsequent values differ in terms of Object.equals(). @param <T> the type of the values @param source the source observable @return the observable

Line: 1488

Returns Ts from the source observable if the subsequent keys extracted by <code>keyExtractor</code> are different. @param <T> the type of the values to observe @param <U> the key type check for distinction @param source the source of Ts @param keyExtractor the etractor for the keys @return the new filtered observable

Line: 1501

Indication as the first.

Line: 1503

The last value.

Line: 1532

Maintains a queue of Ts which is then drained by the pump. Uses the default pool. FIXME not sure what this method should do and how. @param <T> the type of the values @param source the source of Ts @param pump the pump that drains the queue @return the new observable

Line: 1543

Maintains a queue of Ts which is then drained by the pump. FIXME not sure what this method should do and how. @param <T> the type of the values @param source the source of Ts @param pump the pump that drains the queue @param pool the pool for the drain @return the new observable

Line: 1557

keep track of the forked observers so the last should invoke finish() on the observer

Line: 1566

FIXME what should happen in this case???

Line: 1577

FIXME what if another pump returns error???

Line: 1601

FIXME what should happen in this case???

Line: 1619

@param <T> the type of the values to observe (irrelevant) @return Returns an empty observable which signals only finish() on the default observer pool.

Line: 1626

Returns an empty observable which signals only finish() on the given pool. @param <T> the expected type, (irrelevant) @param pool the pool to invoke the the finish() @return the observable

Line: 1647

Creates a filtered observable where only Ts are relayed which satisfy the clause. @param <T> the element type @param source the source of Ts @param clause the filter clause @return the new observable

Line: 1680

Invokes the given action when the source signals a finish() or error(). @param <T> the type of the observed values @param source the source of Ts @param action the action to invoke on finish() or error() @return the new observable

Line: 1714

Blocks until the first element of the observable becomes availabel and returns that element. Might block forever. Might throw a NoSuchElementException when the observable doesn't produce any more elements @param <T> the type of the elements @param source the source of Ts @return the first element

Line: 1729

Creates a concatenated sequence of Observables based on the decision function of <code>selector</code> keyed by the source iterable. FIXME not sure for the reason of this method @param <T> the type of the source values @param <U> the type of the observable elements. @param source the source of keys @param selector the selector of keys which returns a new observable @return the concatenated observable.

Line: 1745

Runs the observables in parallel and joins their last values whenever one fires. FIXME not sure what this method should do in case of error. @param <T> the type of the source values @param sources the list of sources @return the observable

Line: 1767

The last value.

Line: 1771

TODO Auto-generated method stub

Line: 1797

Runs the completion sequence once the WIP drops to zero. @param observer the observer who will receive the values @param lastValues the array of last values @param wip the work in progress counter

Line: 1818

Generates a stream of Us by using a value T stream using the default pool fo the generator loop. If T = int and U is double, this would be seen as for (int i = 0; i &lt; 10; i++) { yield return i / 2.0; } @param <T> the type of the generator values @param <U> the type of the observed values @param initial the initial generator value @param condition the condition that must hold to continue generating Ts @param next the function that computes the next value of T @param selector the selector which turns Ts into Us. @return the observable

Line: 1833

Generates a stream of Us by using a value T stream. If T = int and U is double, this would be seen as for (int i = 0; i &lt; 10; i++) { yield return i / 2.0; } @param <T> the type of the generator values @param <U> the type of the observed values @param initial the initial generator value @param condition the condition that must hold to continue generating Ts @param next the function that computes the next value of T @param selector the selector which turns Ts into Us. @param pool the thread pool where the generation loop should run. @return the observable

Line: 1868

Generates a stream of Us by using a value T stream. If T = int and U is double, this would be seen as for (int i = 0; i &lt; 10; i++) { sleep(time); yield return i / 2.0; } @param <T> the type of the generator values @param <U> the type of the observed values @param initial the initial generator value @param condition the condition that must hold to continue generating Ts @param next the function that computes the next value of T @param selector the selector which turns Ts into Us. @param delay the selector which tells how much to wait before releasing the next U @return the observable

Line: 1884

Generates a stream of Us by using a value T stream. If T = int and U is double, this would be seen as for (int i = 0; i &lt; 10; i++) { sleep(time); yield return i / 2.0; } @param <T> the type of the generator values @param <U> the type of the observed values @param initial the initial generator value @param condition the condition that must hold to continue generating Ts @param next the function that computes the next value of T @param selector the selector which turns Ts into Us. @param delay the selector which tells how much to wait (in milliseconds) before releasing the next U @param pool the scheduled pool where the generation loop should run. @return the observable

Line: 1902

the cancellation indicator

Line: 1930

@return the current default pool used by the Observables methods

Line: 1936

Replace the current default scheduler with the specified  new scheduler. This method is threadsafe @param newScheduler the new scheduler @return the current scheduler

Line: 1948

Restore the default scheduler back to the <code>DefaultScheduler</code> used when this class was initialized.

Line: 1955

Group the specified source accoring to the keys provided by the extractor function. The resulting observable gets notified once a new group is encountered. Each previously encountered group by itself receives updates along the way. If the source finish(), all encountered group will finish(). FIXME not sure how this should work. @param <T> the type of the source element @param <Key> the key type of the group @param source the source of Ts @param keyExtractor the key extractor which creates Keys from Ts @return the observable

Line: 1970

Group the specified source accoring to the keys provided by the extractor function. The resulting observable gets notified once a new group is encountered. Each previously encountered group by itself receives updates along the way. If the source finish(), all encountered group will finish(). FIXME not sure how this should work @param <T> the type of the source element @param <U> the type of the output element @param <Key> the key type of the group @param source the source of Ts @param keyExtractor the key extractor which creates Keys from Ts @param valueExtractor the extractor which makes Us from Ts @return the observable

Line: 2023

Returns an observable where the submitted condition decides whether the <code>then</code> source is allowed to submit values. @param <T> the type of the values to observe @param condition the condition function @param then the source to use when the condition is true @return the observable

Line: 2033

Returns an observable where the submitted condition decides whether the <code>then</code> or <code>orElse</code> source is allowed to submit values. FIXME not sure how it should work @param <T> the type of the values to observe @param condition the condition function @param then the source to use when the condition is true @param orElse the source to use when the condition is false @return the observable

Line: 2100

Invoke a specific action before relaying the Ts to the observable. The <code>action</code> might have some effect on each individual Ts passing through this filter. @param <T> the type of the values observed @param source the source of Ts @param action the action to invoke on every T @return the new observable

Line: 2133

Invoke a specific observer before relaying the Ts, finish() and error() to the observable. The <code>action</code> might have some effect on each individual Ts passing through this filter. @param <T> the type of the values observed @param source the source of Ts @param observer the observer to invoke before any registered observers are called @return the new observable

Line: 2148

FIXME should this also happen?

Line: 2154

FIXME should this also happen?

Line: 2168

Invoke the given callable on the default pool and observe its result via the returned observable. Any exception thrown by the callable is relayed via the error() message. @param <T> the return type @param call the callable @return the observable

Line: 2178

Invoke the given callable on the given pool and observe its result via the returned observable. Any exception thrown by the callable is relayed via the error() message. @param <T> the return type @param call the callable @param pool the thread pool @return the observable

Line: 2204

Invoke the given callable on the given pool and observe its result via the returned observable. Any exception thrown by the callable is relayed via the error() message. @param <T> the return type @param run the runnable @return the observable

Line: 2214

Invoke the given callable on the given pool and observe its result via the returned observable. Any exception thrown by the callable is relayed via the error() message. @param <T> the return type @param run the runnable @param pool the thread pool @return the observable

Line: 2240

Signals true if the source observable fires finish() without ever firing next(). This means once the next() is fired, the resulting observer will return early. @param source the source observable of any type @return the observer

Line: 2251

We already determined the answer?

Line: 2282

Returns the last element of the source observable or throws NoSuchElementException if the source is empty. @param <T> the type of the elements @param source the source of Ts @return the last element

Line: 2292

The current value.

Line: 2294

Are we the first?

Line: 2330

Returns an iterable which returns values on a momentary basis from the source. Useful when source produces values at different rate than the consumer takes it. The iterable.next() call might block until the first value becomes available or something else happens in the observable FIXME not sure where the observer should run @param <T> the type of the values @param source the source @return the iterable

Line: 2348

Set the has value once.

Line: 2404

Returns the maximum value encountered in the source observable onse it finish(). @param <T> the element type which must be comparable to itself @param source the source of integers @return the the maximum value

Line: 2415

Is this the first original value?

Line: 2417

Keeps track of the maximum value.

Line: 2444

Returns the maximum value encountered in the source observable onse it finish(). @param <T> the element type @param source the source of integers @param comparator the comparator to decide the relation of values @return the the maximum value

Line: 2456

Is this the first original value?

Line: 2458

Keeps track of the maximum value.

Line: 2485

Returns an observable which provides with the list of <code>T</code>s which had their keys as maximums. The returned observer may finish() if the source sends finish() without any next(). The generated list is modifiable. @param <T> the type of elements @param <Key> the key type, which must be comparable to itself @param source the source of <code>T</code>s @param keyExtractor the key extractor to produce <code>Key</code>s from <code>T</code>s. @return the observable for the maximum keyed Ts

Line: 2500

The current collection for the minimum of Ts.

Line: 2502

The current minimum value.

Line: 2541

Returns an observable which provides with the list of <code>T</code>s which had their keys as maximums. The returned observer may finish() if the source sends finish() without any next(). The generated list is modifiable. @param <T> the type of elements @param <Key> the key type @param source the source of <code>T</code>s @param keyExtractor the key extractor to produce <code>Key</code>s from <code>T</code>s. @param keyComparator the comparator for the keys @return the observable for the maximum keyed Ts

Line: 2558

The current collection for the minimum of Ts.

Line: 2560

The current minimum value.

Line: 2599

Combines the notifications of all sources. The resulting stream of Ts might come from any of the sources. @param <T> the type of the values @param sources the list of sources @return the observable

Line: 2649

Merge the events of two observable sequences. @param <T> the type of the elements @param first the first observable @param second the second observable @return the merged observable

Line: 2662

Returns the minimum value encountered in the source observable onse it finish(). @param <T> the element type which must be comparable to itself @param source the source of integers @return the the minimum value

Line: 2673

Is this the first original value?

Line: 2675

Keeps track of the maximum value.

Line: 2702

Returns the minimum value encountered in the source observable onse it finish(). @param <T> the element type @param source the source of integers @param comparator the comparator to decide the relation of values @return the the minimum value

Line: 2714

Is this the first original value?

Line: 2716

Keeps track of the maximum value.

Line: 2743

Returns an observable which provides with the list of <code>T</code>s which had their keys as minimums. The returned observer may finish() if the source sends finish() without any next(). The generated list is modifiable. @param <T> the type of elements @param <Key> the key type, which must be comparable to itself @param source the source of <code>T</code>s @param keyExtractor the key extractor to produce <code>Key</code>s from <code>T</code>s. @return the observable for the minimum keyed Ts

Line: 2758

The current collection for the minimum of Ts.

Line: 2760

The current minimum value.

Line: 2799

Returns an observable which provides with the list of <code>T</code>s which had their keys as minimums. The returned observer may finish() if the source sends finish() without any next(). The generated list is modifiable. @param <T> the type of elements @param <Key> the key type @param source the source of <code>T</code>s @param keyExtractor the key extractor to produce <code>Key</code>s from <code>T</code>s. @param keyComparator the comparator for the keys @return the observable for the minimum keyed Ts

Line: 2816

The current collection for the minimum of Ts.

Line: 2818

The current minimum value.

Line: 2857

Returns an observable which never fires. @param <T> the type of the observable, irrelevant @return the observable

Line: 2870

Wrap the given observable object in a way that any of its observers receive callbacks on the given thread pool. @param <T> the type of the objects to observe @param source the original observable @param pool the target observable @return the new observable

Line: 2935

Creates an observer with debugging purposes. It prints the submitted values to STDOUT separated by commas and line-broken by 80 characters, the exceptions to STDERR and prints an empty newline when it receives a finish(). @param <T> the value type @return the observer

Line: 2945

Creates an observer with debugging purposes. It prints the submitted values to STDOUT, the exceptions to STDERR and prints an empty newline when it receives a finish(). @param <T> the value type @param separator the separator to use between subsequent values @param maxLineLength how many characters to print into each line @return the observer

Line: 2956

Indicator for the first element.

Line: 2958

The current line length.

Line: 2995

Creates an observer with debugging purposes. It prints the submitted values to STDOUT with a line break, the exceptions to STDERR and prints an empty newline when it receives a finish(). @param <T> the value type @return the observer

Line: 3018

Creates an observer with debugging purposes. It prints the submitted values to STDOUT with a line break, the exceptions to STDERR and prints an empty newline when it receives a finish(). @param <T> the value type @param prefix the prefix to use when printing @return the observer

Line: 3045

Creates an observable which generates numbers from start. @param start the start value. @param count the count @param step the stepping @return the observable

Line: 3056

Creates an observable which generates BigDecimal numbers from start. @param start the start value. @param count the count @param step the stepping @param pool the execution thread pool. @return the observable

Line: 3087

Creates an observable which generates numbers from start. @param start the start value. @param count the count @return the observable

Line: 3096

Creates an observable which generates BigInteger numbers from start. @param start the start value. @param count the count @param pool the execution thread pool. @return the observable

Line: 3126

Creates an observable which generates numbers from start. @param start the start value. @param count the count @param step the stepping @return the observable

Line: 3137

Creates an observable which produces Double values from <code>start</code> in <code>count</code> amount and each subsequent element has a difference of <code>step</code>. @param start the starting value @param count how many values to produce @param step the incrementation amount @param pool the pool where to emit the values @return the observable of float

Line: 3168

Creates an observable which generates numbers from start. @param start the start value. @param count the count @param step the stepping @return the observable

Line: 3178

Creates an observable which produces Float values from <code>start</code> in <code>count</code> amount and each subsequent element has a difference of <code>step</code>. @param start the starting value @param count how many values to produce @param step the incrementation amount @param pool the pool where to emit the values @return the observable of float

Line: 3209

Creates an observable which generates numbers from start. @param start the start value. @param count the count @return the observable

Line: 3218

Creates an observable which generates numbers from start. @param start the start value. @param count the count @param pool the execution thread pool. @return the observable

Line: 3245

Relay values of T while the given condition does not hold. Once the condition turns true the relaying stops. @param <T> the element type @param source the source of elements @param condition the condition that must be false to relay Ts @return the new observable

Line: 3256

Relay the stream of Ts until condition turns into false. @param <T> the type of the values @param source the source of Ts @param condition the condition that must hold to relay Ts @return the new observable

Line: 3268

Are we done?

Line: 3306

Unwrap the values within a timeinterval observable to its normal value. @param <T> the element type @param source the source which has its elements in a timeinterval way. @return the raw observables of Ts

Line: 3315

Unwrap the values within a timestamped observable to its normal value. @param <T> the element type @param source the source which has its elements in a timestamped way. @return the raw observables of Ts

Line: 3324

Creates an observable which repeatedly calls the given function which generates the Ts indefinitely. The generator runs on the default pool. Note that observers must unregister to stop the infinite loop. @param <T> the type of elements to produce @param func the function which generates elements @return the observable

Line: 3334

Creates an observable which repeatedly calls the given function which generates the Ts indefinitely. The generator runs on the pool. Note that observers must unregister to stop the infinite loop. @param <T> the type of elements to produce @param func the function which generates elements @param pool the pool where the generator loop runs @return the observable

Line: 3359

Creates an observable which repeatedly calls the given function <code>count</code> times to generate Ts and runs on the default pool. @param <T> the element type @param func the function to call to generate values @param count the numer of times to repeat the value @return the observable

Line: 3370

Creates an observable which repeatedly calls the given function <code>count</code> times to generate Ts and runs on the given pool. @param <T> the element type @param func the function to call to generate values @param count the numer of times to repeat the value @param pool the pool where the loop should be executed @return the observable

Line: 3400

Repeat the source observable count times. Basically it creates a list of observables, all the source instance and applies the concat() operator on it. @param <T> the element type @param source the source observable @param count the number of times to repeat @return the new observable

Line: 3419

Creates an observable which repeates the given value indefinitely and runs on the default pool. Note that the observers must deregister to stop the infinite background loop @param <T> the element type @param value the value to repeat @return the observable

Line: 3430

Creates an observable which repeates the given value indefinitely and runs on the given pool. Note that the observers must deregister to stop the infinite background loop @param <T> the element type @param value the value to repeat @param pool the pool where the loop should be executed @return the observable

Line: 3442

Creates an observable which repeates the given value <code>count</code> times and runs on the default pool. @param <T> the element type @param value the value to repeat @param count the numer of times to repeat the value @return the observable

Line: 3453

Creates an observable which repeates the given value <code>count</code> times and runs on the given pool. @param <T> the element type @param value the value to repeat @param count the numer of times to repeat the value @param pool the pool where the loop should be executed @return the observable

Line: 3465

Returns an observable which listens to elements from a source until it signals an error() or finish() and continues with the next observable. The registration happens only when the previous observables finished in any way. FIXME not sure how to close previous registrations @param <T> the type of the elements @param sources the list of observables @return the observable

Line: 3514

It tries to submit the values of first observable, but when it throws an exeption, the next observable within source is used further on. Basically a failover between the Observables. If the current source finish() then the result observable calls finish(). If the last of the sources calls error() the result observable calls error() FIXME not sure how to close previous registrations @param <T> the type of the values @param sources the available source observables. @return the failover observable

Line: 3560

Restarts the observation until the source observable terminates normally. @param <T> the type of elements @param source the source observable @return the repeating observable

Line: 3594

Restarts the observation until the source observable terminates normally or the <code>count</code> retry count was used up. FIXME if the retry count is zero and yet another error comes, what should happen? finish or this time submit the error? @param <T> the type of elements @param source the source observable @param count the retry count @return the repeating observable

Line: 3607

The remaining retry count.

Line: 3615

FIXME not sure

Line: 3636

Blocks until the observable calls finish() or error(). Values are ignored. @param source the source observable @throws InterruptedException if the current thread is interrupted while waiting on the observable.

Line: 3645

Are we finished?

Line: 3675

Blocks until the observable calls finish() or error() or the specified amount of time ellapses. Values are ignored. FIXME might be infeasible due the potential side effects along the event stream @param source the source observable @param time the time value @param unit the time unit @return false if the waiting time ellapsed before the run completed @throws InterruptedException if the current thread is interrupted while waiting on the observable.

Line: 3688

Are we finished?

Line: 3718

Blocks until the observable calls finish() or error(). Values are submitted to the given action. @param <T> the type of the elements @param source the source observable @param action the action to invoke for each value @throws InterruptedException if the current thread is interrupted while waiting on the observable.

Line: 3729

Are we finished?

Line: 3759

Blocks until the observable calls finish() or error(). Events are submitted to the given observer. @param <T> the type of the elements @param source the source observable @param observer the observer to invoke for each event @throws InterruptedException if the current thread is interrupted while waiting on the observable.

Line: 3770

Are we finished?

Line: 3802

Periodically sample the given source observable, which means tracking the last value of the observable and periodically submitting it to the output observable. FIXME the error() and finish() are instantly propagated @param <T> the type of elements to watch @param source the source of elements @param time the time value to wait @param unit the time unit @return the sampled observable

Line: 3815

Periodically sample the given source observable, which means tracking the last value of the observable and periodically submitting it to the output observable. FIXME the error() and finish() are instantly propagated @param <T> the type of elements to watch @param source the source of elements @param time the time value to wait @param unit the time unit @param pool the scheduler pool where the periodic submission should happen. @return the sampled observable

Line: 3832

Are we waiting for the first event?

Line: 3834

The current value.

Line: 3868

Use the mapper to transform the T source into an U source. @param <T> the type of the original observable @param <U> the type of the new observable @param source the source of Ts @param mapper the mapper from Ts to Us @return the observable on Us

Line: 3900

Transforms the elements of the source observable into Us by using a selector which receives an index indicating how many elements have been transformed this far. @param <T> the source element type @param <U> the output element type @param source the source observable @param selector the selector taking an index and the current T @return the transformed observable

Line: 3914

The running index.

Line: 3935

Transform the given source of Ts into Us in a way that the selector might return an observable ofUs for a single T. The observable is fully channelled to the output observable. FIXME not sure how to do it @param <T> the input element type @param <U> the output element type @param source the source of Ts @param selector the selector to return an Iterable of Us @return the

Line: 3955

Creates an observable in which for each of Ts an observable of Vs are requested which in turn will be transformed by the resultSelector for each pair of T and V giving an U. FIXME concurrency related questions @param <T> the source element type @param <U> the output element type @param <V> the intermediate element type @param source the source of Ts @param collectionSelector the selector which returns an observable of intermediate Vs @param resultSelector the selector which gives an U for a T and V @return the observable of Us

Line: 4037

Creates an observable of Us in a way when a source T arrives, the observable of Us is completely drained into the output. This is done again and again for each arriving Ts. @param <T> the type of the source, irrelevant @param <U> the output type @param source the source of Ts @param provider the source of Us @return the observable for Us

Line: 4050

Transform the given source of Ts into Us in a way that the selector might return zero to multiple elements of Us for a single T. The iterable is flattened and submitted to the output @param <T> the input element type @param <U> the output element type @param source the source of Ts @param selector the selector to return an Iterable of Us @return the

Line: 4087

Wraps the given observer into a form, which ensures that only one observer method is invoked at the same time and error() and finish() messages disable any further message relaying. It uses a fair ReentrantLock. @param <T> the element type @param observer the observer to wrap @return the new wrapped observer

Line: 4098

Wraps the given observer into a form, which ensures that only one observer or runnable method is invoked at the same time and error() and finish() messages disable any further message relaying. If you have a class that implements some of these interfaces by itself, assign it to each of the parameters. @param <T> the element type @param observer the observer to wrap @param run the runnable to wrap @param close the closeable to wrap @param lock the lock to use for exclusion. @return the new observable

Line: 4124

The aliveness indicator.

Line: 4130

FIXME not sure

Line: 4136

lock.lock();

Line: 4137

try {

Line: 4138

if (alive.get())  {

Line: 4139

try {

Line: 4140

close.close();

Line: 4141

} finally {

Line: 4142

alive.set(false);

Line: 4143

}

Line: 4144

}

Line: 4145

} finally {

Line: 4146

lock.unlock();

Line: 4147

}

Line: 4199

Returns the single element of the given observable source. If the source is empty, a NoSuchElementException is thrown. If the source has more than one element, a TooManyElementsException is thrown. @param <T> the type of the element @param source the source of Ts @return the single element

Line: 4218

Returns the single value in the observables. @param <T> the value type @param value the value @return the observable

Line: 4227

Returns the single value in the observables. @param <T> the value type @param value the value @param pool the pool where to submit the value to the observers @return the observable

Line: 4250

Skips the given amount of next() messages from source and relays the rest. @param <T> the element type @param source the source of Ts @param count the number of messages to skip @return the new observable

Line: 4286

Skips the last <code>count</code> elements from the source observable. @param <T> the element type @param source the source of Ts @param count the number of elements to skip at the end @return the new observable

Line: 4298

The temporar buffer to delay the values.

Line: 4300

The current size of the buffer.

Line: 4326

Skip the source elements until the signaller sends its first element. FIXME: If the signaller sends an error or only finish(), the relaying is never enabled? FIXME: once the singaller fires, it gets deregistered @param <T> the element type of the source @param <U> the element type of the signaller, irrelevant @param source the source of Ts @param signaller the source of Us @return the new observable

Line: 4392

Skips the Ts from source while the specified condition returns true. If the condition returns false, all subsequent Ts are relayed, ignoring the condition further on. Errors and completion is relayed regardless of the condition. @param <T> the element types @param source the source of Ts @param condition the condition that must turn false in order to start relaying @return the new observable

Line: 4407

Can we relay stuff?

Line: 4435

Invokes the action asynchronously on the given pool and relays its finish() or error() messages. @param action the action to invoke @return the observable

Line: 4444

Invokes the action asynchronously on the given pool and relays its finish() or error() messages. @param action the action to invoke @param pool the pool where the action should run @return the observable

Line: 4471

Invokes the function asynchronously on the default pool and relays its result followed by a finish. Exceptions are relayed as well. @param <T> the function return type @param func the function @return the observable

Line: 4482

Invokes the function asynchronously on the given pool and relays its result followed by a finish. Exceptions are relayed as well. @param <T> the function return type @param func the function @param pool the pool where the action should run @return the observable

Line: 4512

Start with the given iterable of values before relaying the Ts from the source. The iterable values are emmitted on the default pool. @param <T> the element type @param source the source @param values the values to start with @return the new observable

Line: 4523

Start with the given iterable of values before relaying the Ts from the source. The iterable values are emmitted on the given pool. @param <T> the element type @param source the source @param values the values to start with @param pool the pool where the iterable values should be emitted @return the new observable

Line: 4535

Wrap the given observable into an new Observable instance, which calls the original subscribe() method on the supplied pool. @param <T> the type of the objects to observe @param observable the original observable @param pool the pool to perform the original subscribe() call @return the new observable

Line: 4548

start the registration asynchronously

Line: 4556

use the disposable future when the deregistration is required

Line: 4564

wait until the dispose becomes available then call it

Line: 4577

Computes the sum of the source Ts by using a <code>sum</code> function. If the source is empty, the result will be empty. The sum will be signalled when all elements of source have been received. @param <T> the type of the source elements @param <U> the type of the sum value @param source the source of Ts @param sum the function which receives the current sum as its first parameter and the current T in its second. For the first T, the sum is invoked with a null as its U parameter. @return the observable

Line: 4594

The sum of the values thus far.

Line: 4618

Computes and signals the sum of the values of the BigDecimal source. The source may not send nulls. @param source the source of BigDecimals to aggregate. @return the observable for the sum value

Line: 4635

Computes and signals the sum of the values of the BigInteger source. The source may not send nulls. @param source the source of BigIntegers to aggregate. @return the observable for the sum value

Line: 4652

Computes and signals the sum of the values of the Double source. The source may not send nulls. @param source the source of Doubles to aggregate. @return the observable for the sum value

Line: 4669

Computes and signals the sum of the values of the Float source. The source may not send nulls. @param source the source of Floats to aggregate. @return the observable for the sum value

Line: 4686

Computes and signals the sum of the values of the Integer source. The source may not send nulls. An empty source produces an empty sum @param source the source of integers to aggregate. @return the observable for the sum value

Line: 4703

Computes and signals the sum of the values of the Long source. The source may not send nulls. @param source the source of longs to aggregate. @return the observable for the sum value

Line: 4720

Wraps the observers registering at the output into an observer which synchronizes on all of its methods using <code>synchronize</code>. Each individual registering observer uses its own synchronization object. @param <T> the element type @param source the source of Ts @return the new observable

Line: 4753

Wraps the observers registering at the output into an observer which synchronizes on all of its methods using <code>synchronize</code>. Each individual registering observer shares the same synchronization @param <T> the element type @param source the source of Ts @param on the syncrhonization object @return the new observable

Line: 4796

Creates an observable which takes the specified number of Ts from the source, unregisters and completes. @param <T> the element type @param source the source of Ts @param count the number of elements to relay @return the new observable

Line: 4813

Creates an observable which takes values from the source until the signaller produces a value. If the signaller never signals, all source elements are relayed. FIXME not sure about the concurrency @param <T> the element type @param <U> the signaller element type, irrelevant @param source the source of Ts @param signaller the source of Us @return the new observable

Line: 4829

FIXME implement correctly?!

Line: 4864

no operation

Line: 4867

The registration handle to the source.

Line: 4917

Invoke the <code>close()</code> method on the closeable instance and throw away any <code>IOException</code> it might raise. @param c the closeable instance, <code>null</code>s are simply ignored

Line: 4931

Creates an observable which takes values from source until the predicate returns true, then skips the remaining values. @param <T> the element type @param source the source of Ts @param predicate the predicate @return the new observable

Line: 4945

The done indicator.

Line: 4981

Creates and observable which fires the last value from source when the given timespan elapsed without a new value occurring from the source. It is basically how Content Assistant popup works after the user pauses in its typing. Uses the default scheduler. @param <T> the value type @param source the source of Ts @param delay how much time should elapse since the last event to actually forward that event @param unit the delay time unit @return the observable

Line: 4996

Creates and observable which fires the last value from source when the given timespan elapsed without a new value occurring from the source. It is basically how Content Assistant popup works after the user pauses in its typing. @param <T> the value type @param source the source of Ts @param delay how much time should elapse since the last event to actually forward that event @param unit the delay time unit @param pool the pool where the delay-watcher should operate @return the observable

Line: 5014

The last seen value.

Line: 5044

Creates an observable which instantly sends the exception to its subscribers while running on the default pool. @param <T> the element type, irrelevant @param ex the exception to throw @return the new observable

Line: 5054

Creates an observable which instantly sends the exception to its subscribers while running on the given pool. @param <T> the element type, irrelevant @param ex the exception to throw @param pool the pool from where to send the values @return the new observable

Line: 5077

Returns an observable which produces an ordered sequence of numbers with the specified delay. It uses the default scheduler pool. @param start the starting value of the tick @param end the finishing value of the tick exclusive @param delay the delay value @param unit the time unit of the delay @return the observer

Line: 5089

Returns an observable which produces an ordered sequence of numbers with the specified delay. @param start the starting value of the tick inclusive @param end the finishing value of the tick exclusive @param delay the delay value @param unit the time unit of the delay @param pool the scheduler pool for the wait @return the observer

Line: 5113

no more scheduling needed

Line: 5122

Returns an observable which produces an ordered sequence of numbers with the specified delay. It uses the default scheduler pool. @param delay the delay value @param unit the time unit of the delay @return the observer

Line: 5132

Creates an observable which relays events if they arrive from the source observable within the specified amount of time or it singlals a java.util.concurrent.TimeoutException. FIXME not sure if the timeout should happen only when distance between elements get to large or just the first element does not arrive within the specified timespan. @param <T> the element type to observe @param source the source observable @param time the maximum allowed timespan between events @param unit the time unit @return the observer.

Line: 5149

Creates an observable which relays events if they arrive from the source observable within the specified amount of time or it switches to the <code>other</code> observable. FIXME not sure if the timeout should happen only when distance between elements get to large or just the first element does not arrive within the specified timespan. @param <T> the element type to observe @param source the source observable @param time the maximum allowed timespan between events @param unit the time unit @param other the other observable to continue with in case a timeout occurs @return the observer.

Line: 5168

Creates an observable which relays events if they arrive from the source observable within the specified amount of time or it switches to the <code>other</code> observable. FIXME not sure if the timeout should happen only when distance between elements get to large or just the first element does not arrive within the specified timespan. @param <T> the element type to observe @param source the source observable @param time the maximum allowed timespan between events @param unit the time unit @param other the other observable to continue with in case a timeout occurs @param pool the scheduler pool for the timeout evaluation @return the observer.

Line: 5191

The lock to prevent overlapping of run and observer messages.

Line: 5193

Flag to indicate if a timeout happened.

Line: 5242

register and continue with the other observable but without timeouts

Line: 5258

Creates an observable which relays events if they arrive from the source observable within the specified amount of time or it singlals a java.util.concurrent.TimeoutException. FIXME not sure if the timeout should happen only when distance between elements get to large or just the first element does not arrive within the specified timespan. @param <T> the element type to observe @param source the source observable @param time the maximum allowed timespan between events @param unit the time unit @param pool the scheduler pool for the timeout evaluation @return the observer.

Line: 5278

The lock to prevent overlapping of run and observer messages.

Line: 5280

Flag to indicate if a timeout happened.

Line: 5344

Filters objects from source which are assignment compatible with T. Note that due java erasure complex generic types can't be filtered this way in runtime (e.g., List&lt;String>.class is just List.class). @param <T> the type of the expected values @param source the source of unknown elements @param token the token to test agains the elements @return the observable containing Ts

Line: 5378

Receives a resource from the resource selector and uses the resource until it terminates, then closes the resource. FIXME not sure how this method should work @param <T> the output resource type. @param <U> the closeable resource to work with @param resourceSelector the function that gives a resource @param resourceUsage a function that returns an observable of T for the given resource. @return the observable of Ts which terminates once the usage terminates

Line: 5423

Creates a filtered observable where only Ts are relayed which satisfy the clause. The clause receives the index and the current element to test. @param <T> the element type @param source the source of Ts @param clause the filter clause, the first parameter receives the current index, the second receives the current element @return the new observable

Line: 5437

The current element index.

Line: 5461

Splits the source stream into separate observables once the windowClosing fires an event. FIXME not sure how to implement @param <T> the element type to observe @param <U> the closing event type, irrelevant @param source the source of Ts @param windowClosing the source of the window splitting events @return the observable on sequences of observables of Ts

Line: 5475

Splits the source stream into separate observables once the windowClosing fires an event. FIXME not sure how to implement @param <T> the element type to observe @param <U> the closing event type, irrelevant @param source the source of Ts @param windowClosing the source of the window splitting events @param pool the pool where ??? @return the observable on sequences of observables of Ts

Line: 5490

Creates an observable which waits for events from left and combines it with the next available value from the right iterable, applies the selector function and emits the resulting T. The error() and finish() signals are relayed to the output. The result is finished if the right iterator runs out of values before the left iterator. @param <T> the resulting element type @param <U> the value type streamed on the left observable @param <V> the value type streamed on the right iterable @param left the left observables of Us @param right the right iterable of Vs @param selector the selector taking the left Us and right Vs. @return the resulting observable

Line: 5538

Creates an observable which waits for events from left and combines it with the next available value from the right observable, applies the selector function and emits the resulting T. Basically it emmits a T when both an U and V is available. The output stream throws error or terminates if any of the streams throws or terminates. FIXME not sure how to implement this, and how to close and signal @param <T> the resulting element type @param <U> the value type streamed on the left observable @param <V> the value type streamed on the right iterable @param left the left observables of Us @param right the right iterable of Vs @param selector the selector taking the left Us and right Vs. @return the resulting observable

Line: 5664

Convert the functional observable into a normal observable object. @param <T> the type of the elements to observe. @param source the source of the functional-observable elements @return the observable object

Line: 5679

Convert the Observable instance into a functional-observable object. @param <T> the type of the elements @param source the source observable @return the action to action to option of T

Line: 5693

Transform the given action to an observer. The wrapper observer converts its next() messages to Option.some(), the finish() to Option.none() and error() to Option.error(). @param <T> the element type to observe @param action the action to wrap @return the observer

Line: 5720

Wraps the given observer into an action object which then dispatches various incoming Option values to next(), finish() and error(). @param <T> the element type @param observer the observer to wrap @return the wrapper action

Line: 5735

Dispatches the option to the various Observer methods. @param <T> the value type @param observer the observer @param value the value to dispatch

Line: 5751

Utility class.

Line: 5753

utility class

Line: 5755

A convenience function which unwraps the T from a Timestamped of T. @param <T> the value type @return the unwrapper function

Line: 5768

A convenience function which unwraps the T from a TimeInterval of T. @param <T> the value type @return the unwrapper function

Line: 5781

Wrap the given type into a timestamped container of T. @param <T> the type of the contained element @return the function performing the wrapping

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\Observer.java
-----------------------------------------------------------------------------

Line: 19

The observer who receives the notifications of T. @author akarnokd @param <T> the type of the notification values.

Line: 25

The next value is received. @param value the next value

Line: 30

An exception is received. @param ex the exception

Line: 35

No more values to expect.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\package-info.java
---------------------------------------------------------------------------------

Line: 17

This package contains the <b>Observables</b> main utility class for the reactive programming side of the library, accompanied by some helper classes.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\RunnableClosableObserver.java
---------------------------------------------------------------------------------------------

Line: 21

A combinational interface for a runnable, closable and an observer, i.e. an observer which has an attached scheduled counterpart and offers the option to close. @author akarnokd, 2011.02.02. @param <T> the element type of the observer

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\RunOnce.java
----------------------------------------------------------------------------

Line: 24

Helper class which ensures that only a single action is invoked. It can be used in cases when multiple observers want to do the same thing (e.g., fire an error() or finish()) but only one of them should ever succeed @author akarnokd, 2011.01.31.

Line: 32

Marker that this instance is allowed to execute only one Action.

Line: 34

Invoke the given action only if this RunOnce has not invoked anything before. The method ensures that if this RunOnce is invoked from multiple threads or multiple cases, only the very first one executes its submitted action. @param action the action to invoke @return returns true if the action was invoked

Line: 49

Invoke the given action only if this RunOnce has not invoked anything before. The method ensures that if this RunOnce is invoked from multiple threads or multiple cases, only the very first one executes its submitted action. @param <T> the parameter type @param action the action to invoke @param parameter the parameter to use when invoking the action. @return true if the action was invoked

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\TimeInterval.java
---------------------------------------------------------------------------------

Line: 19

An immutable record holding a value and a time interval value. @author akarnokd, 2011.01.29. @param <T> the contained type

Line: 26

The value.

Line: 28

The timestamp.

Line: 30

Construct a value with a time inverval. @param value the value @param interval the time interval

Line: 39

@return the contained value

Line: 43

@return the associated timestamp.

Line: 47

A type inference helper to construct a new TimeInterval value. @param <T> the type of the value @param value the value @param interval the time interval @return the timestamped object

Line: 57

A type inference helper to construct a new TimeInterval value from another timestamped value by keeping the value and assigning a new value. @param <T> the type of the value @param value the value @param interval the time interval @return the timestamped object

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\reactive\Timestamped.java
--------------------------------------------------------------------------------

Line: 20

An immutable record holding a value and timestamp pairs. @author akarnokd, 2011.01.29. @param <T> the contained type

Line: 26

The value.

Line: 28

The timestamp.

Line: 30

Construct a new timestamped value. @param value the value @param timestamp the timestamp

Line: 39

@return the contained value

Line: 43

@return the associated timestamp.

Line: 47

A type inference helper to construct a new timestamped value. @param <T> the type of the value @param value the value @param timestamp the timestamp @return the timestamped object

Line: 57

A type inference helper to construct a new timestamped value from another timestamped value by keeping the value and assigning a new value. @param <T> the type of the value @param value the value @param timestamp the timestamp @return the timestamped object

Line: 68

A type inference helper to construct a new timestamped value where the timestamp is the System.currentTimeMillis(). @param <T> the type of the value @param value the value @return the timestamped object

Line: 78

A type inference helper to construct a new timestamped value from another timestamped value where the new timestamp is the System.currentTimeMillis(). @param <T> the type of the value @param value the value @return the timestamped object

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\swing\Dynamic.java
-------------------------------------------------------------------------

Line: 23

Defines a composite class holding a dynamic method invocation arguments, i.e., [method, arguments...]. @author akarnokd, 2011.02.01.

Line: 28

The original method name.

Line: 30

The original method arguments.

Line: 32

Construct a new dynamic object with the given parameters. @param method the method name @param arguments the argument list

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\swing\package-info.java
------------------------------------------------------------------------------

Line: 17

This package contains helper methods to interface the Swing's event notification mechanisms (e.g., various Listener interfaces) with the reactive programming's Observable based approach.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\swing\SwingObservables.java
----------------------------------------------------------------------------------

Line: 60

Utility class to wrap typical Swing events into observables. @author akarnokd, 2011.02.01.

Line: 65

Utility class.

Line: 67

utility class

Line: 69

The common observable pool where the Observer methods get invoked by default.

Line: 71

The observable action listener which relays the actionPerformed() calls to next() calls. This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 81

Convenience method to create a new observable action listener and register it with the target component must have a public <code>addActionListener(ActionListener)</code> method. @param component the target component @return the new observable

Line: 89

Convenience method to register this observable with the target component which must have a public <code>addActionListener(ActionListener)</code> method. @param component the target component @return this

Line: 97

Convenience method to unregister this observable from the target component which must have a public <code>removeActionListener(ActionListener)</code> method. @param component the target component @return this

Line: 106

The observable change listener which relays the stateChanged() calls to next() calls. This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 116

Convenience method to create a new observable action listener and register it with the target component must have a public <code>addActionListener(ActionListener)</code> method. @param component the target component @return the new observable

Line: 124

Convenience method to register this observable with the target component which must have a public <code>addChangeListener(ChangeListener)</code> method. @param component the target component @return this

Line: 132

Convenience method to unregister this observable from the target component which must have a public <code>removeChangeListener(ChangeListener)</code> method. @param component the target component @return this

Line: 141

The observable document listener which relays the insertUpdate(), removeUpdate() and changedUpdate() events to next() calls. The original event type can be queried from the DocumentEvent.getType(). This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 163

Convenience method to create a new observable action listener and register it with the target component must have a public <code>addDocumentListener(DocumentListener)</code> method. @param component the target component @return the new observable

Line: 171

Convenience method to register this observable with the target component which must have a public <code>addDocumentListener(DocumentListener)</code> method. @param component the target component @return this

Line: 179

Convenience method to unregister this observable from the target component which must have a public <code>removeDocumentListener(DocumentListener)</code> method. @param component the target component @return this

Line: 188

The observable list data listener which relays the intervalAdded(), intervalRemoved() and contentsChanged() events to next() calls. The original event type can be determined from the ListDataEvent.getType(). This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 209

Convenience method to create a new observable action listener and register it with the target component must have a public <code>addListDataListener(ListDataListener)</code> method. @param component the target component @return the new observable

Line: 217

Convenience method to register this observable with the target component which must have a public <code>addListDataListener(ListDataListener)</code> method. @param component the target component @return this

Line: 225

Convenience method to unregister this observable from the target component which must have a public <code>removeListDataListener(ListDataListener)</code> method. @param component the target component @return this

Line: 234

The observable list selection listener which relays the valueChanged() events to next(). This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 246

Convenience method to create a new observable action listener and register it with the target component must have a public <code>addListSelectionListener(ListSelectionListener)</code> method. @param component the target component @return the new observable

Line: 254

Convenience method to register this observable with the target component which must have a public <code>addListSelectionListener(ListSelectionListener)</code> method. @param component the target component @return this

Line: 262

Convenience method to unregister this observable from the target component which must have a public <code>removeListSelectionListener(ListSelectionListener)</code> method. @param component the target component @return this

Line: 271

The observable adjustment listener which relays adjustmentValueChanged() events to next(). This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 281

Convenience method to create a new observable action listener and register it with the target component must have a public <code>addAdjustmentListener(AdjustmentListener)</code> method. @param component the target component @return the new observable

Line: 289

Convenience method to register this observable with the target component which must have a public <code>addAdjustmentListener(AdjustmentListener)</code> method. @param component the target component @return this

Line: 301

Convenience method to unregister this observable from the target component which must have a public <code>removeAdjustmentListener(AdjustmentListener)</code> method. @param component the target component @return this

Line: 314

The observable key listener which collects the <code>keyTyped()</code>, <code>keyPressed()</code>, <code>keyReleased()</code> events and relays it to next(). The original type can be determined by using <code>KeyEvent.getType()</code>. This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 336

Convenience method to register an action listener on an object which should have an <code>addKeyListener()</code> public method. It uses reflection to detemine the method's existence. Throws IllegalArgumentException if the component is null or does not have the required method. @param component the target component. @return the observable action listener

Line: 346

Convenience method to register this observable with the target component which must have a public <code>addKeyListener(KeyListener)</code> method. @param component the target component @return this

Line: 354

Convenience method to unregister this observable from the target component which must have a public <code>removeKeyListener(KeyListener)</code> method. @param component the target component @return this

Line: 363

Invoke the methodPrefix + paramType.getSimpleName method (i.e., "add" and ActionListener.class will produce addActionListener) on the object and wrap any exception into IllegalArgumentException. @param <T> the method parameter type @param <U> a type which extends the method parameter type T. @param o the target object @param methodPrefix the method name prefix @param paramType the required parameter type @param value the value to invoke with @return the value

Line: 390

The observable mouse listener which relays all mouse related events (movement, clicks, wheel) to next(). events and relays it to next(). The original type can be determined by using <code>MouseEvent.getID()</code> which can be one of the following value: <ul> <li>MouseListener events <ul> <li><code>MouseEvent.MOUSE_CLICKED</code></li> <li><code>MouseEvent.MOUSE_PRESSED</code></li> <li><code>MouseEvent.MOUSE_RELEASED</code></li> <li><code>MouseEvent.MOUSE_ENTERED</code></li> <li><code>MouseEvent.MOUSE_EXITED</code></li> </ul> </li> <li>MouseMotionListener events <ul> <li><code>MouseEvent.MOUSE_MOVED</code></li> <li><code>MouseEvent.MOUSE_DRAGGED</code></li> </ul> </li> <li>MouseWheelListener events <ul> <li><code>MouseEvent.MOUSE_WHEEL</code></li> </ul> </li> </ul> This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 459

Convenience method to register an observer on the component for all mouse event types. To unregister, use the <code>Component.removeMouseListener()</code>, <code>Component.removeMouseMotionListener()</code> and <code>Component.removeMouseWheelListener()</code> methods. @param component the target component. @return the new observable

Line: 469

Convenience method to register this observer with the target component for all mouse event types. To deregister this observable, use the <code>unregisterFrom()</code>. @param component the target component @return this

Line: 478

Convenience method to register this observer with the target component for any mouse event types. To deregister this observable, use the <code>unregisterFrom()</code>. @param component the target component @param normal register for normal events? @param motion register for motion events? @param wheel register for wheel events? @return this

Line: 502

Unregister all mouse events from the given component. @param component the target component @return this

Line: 517

The observable window listener which relays events from <code>WindowListener</code>, <code>WindowFocusListener</code> and <code>WindowStateListener</code>. The <code>WindowEvent.getID()</code> contains the original event type: <ul> <li>WindowListener events: <ul> <li>WindowEvent.WINDOW_OPENED</li> <li>WindowEvent.WINDOW_CLOSING</li> <li>WindowEvent.WINDOW_CLOSED</li> <li>WindowEvent.WINDOW_ICONIFIED</li> <li>WindowEvent.WINDOW_DEICONIFIED</li> <li>WindowEvent.WINDOW_ACTIVATED</li> <li>WindowEvent.WINDOW_DEACTIVATEd</li> </ul> </li> <li>WindowFocusListener events: <ul> <li>WindowEvent.WINDOW_GAINED_FOCUS</li> <li>WindowEvent.WINDOW_LOST_FOCUS</li> </ul> </li> <li>WindowStateListener events: <ul> <li>WindowEvent.WINDOW_STATE_CHANGED</li> </ul> </li> </ul> This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 598

Convenience method to register an observer on the component for all window event types. To unregister, use the <code>Component.removeMouseListener()</code>, <code>Component.removeMouseMotionListener()</code> and <code>Component.removeMouseWheelListener()</code> methods. @param component the target component. @return the new observable

Line: 608

Convenience method to register this observer with the target component for all window event types. To deregister this observable, use the <code>unregisterFrom()</code>. @param component the target component @return this

Line: 617

Convenience method to register this observer with the target component for any window event types. To deregister this observable, use the <code>unregisterFrom()</code>. @param component the target component @param normal register for normal events? @param focus register for focus events? @param state register for state events? @return this

Line: 641

Unregister all window events from the given component. @param component the target component @return this

Line: 656

The observable item listener which relays events from <code>ItemListener</code>. This observable never signals finish() or error(). @author akarnokd, 2011.02.01.

Line: 667

Convenience method to register an observer on the component for <code>itemStateChanged(ItemEvent)</code> events. @param component the target component. @return the new observable

Line: 675

Convenience method to register an observer on the component for <code>itemStateChanged(ItemEvent)</code> events. @param component the target component. @return the new observable

Line: 683

Unregister this observer of list events from the given component. @param component the target component @return this

Line: 692

Create a dynamic observer for the given listener interface by proxying all method calls. None of the methods of the listener interface should require something meaningful to be returned, i.e., they all must be <code>void</code>, return <code>Void</code> (or the original call site should accept <code>null</code>s). Note that due this proxying effect, the handler invocation may be 100 times slower than a direct implementation @param <T> the listener interface type @param listener the list interface class @param bindTo the target observer, use the DefaultObservable @return the proxy instance

Line: 714

Wrap the observable to the Event Dispatch Thread for listening to events. @param <T> the value type to observe @param observable the original observable @return the new observable

Line: 723

@return the current default pool used by the Observables methods

Line: 729

Replace the current default scheduler with the specified  new scheduler. This method is threadsafe @param newScheduler the new scheduler @return the current scheduler

Line: 741

Restore the default scheduler back to the <code>DefaultScheduler</code> used when this class was initialized.

Line: 748

Wrap the observable to the Event Dispatch Thread for subscribing to events. @param <T> the value type to observe @param observable the original observable @return the new observable

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\package-info.java
-----------------------------------------------------------------------------

Line: 17

This package contains simple test programs for various reactive and interactive operators.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test.java
---------------------------------------------------------------------

Line: 33

Test program for the MinLinq stuff. @author akarnokd

Line: 39

Utility class.

Line: 43

utility class

Line: 46

@param args no arguments @throws Exception on error

Line: 93

TODO Auto-generated method stub

Line: 98

TODO Auto-generated method stub

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test2.java
----------------------------------------------------------------------

Line: 30

Test program for the MinLinq stuff. @author akarnokd

Line: 36

Utility class.

Line: 40

utility class

Line: 43

@param args no arguments @throws Exception on error

Line: 50

System.out.println(Observables.first(Observables.range(2, 0)));

Line: 83

System.out.println("New group: " + value.key());

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test3.java
----------------------------------------------------------------------

Line: 28

Test program for the MinLinq stuff. @author akarnokd

Line: 34

Utility class.

Line: 38

utility class

Line: 41

@param args no arguments @throws Exception on error

Line: 63

System.out.println("New group: " + value.key());

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test4.java
----------------------------------------------------------------------

Line: 25

Test program for the MinLinq stuff. @author akarnokd

Line: 31

Utility class.

Line: 35

utility class

Line: 38

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test5.java
----------------------------------------------------------------------

Line: 24

Test program for the MinLinq stuff. @author akarnokd

Line: 30

Utility class.

Line: 34

utility class

Line: 37

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test6.java
----------------------------------------------------------------------

Line: 30

Test program for the MinLinq stuff. @author akarnokd

Line: 36

Utility class.

Line: 40

utility class

Line: 42

Run the observable with a print attached. @param observable the source observable @throws InterruptedException when the current thread is interrupted while waiting on the observable completion

Line: 52

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test7.java
----------------------------------------------------------------------

Line: 26

Test program for the MinLinq stuff. @author akarnokd

Line: 32

Utility class.

Line: 36

utility class

Line: 38

Run the observable with a print attached. @param observable the source observable @throws InterruptedException when the current thread is interrupted while waiting on the observable completion

Line: 48

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test8.java
----------------------------------------------------------------------

Line: 25

Test program for the MinLinq stuff. @author akarnokd

Line: 31

Utility class.

Line: 35

utility class

Line: 37

Run the observable with a print attached. @param observable the source observable @throws InterruptedException when the current thread is interrupted while waiting on the observable completion

Line: 47

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\Test9.java
----------------------------------------------------------------------

Line: 24

Test program . @author akarnokd

Line: 30

Utility class.

Line: 34

utility class

Line: 36

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\TestA.java
----------------------------------------------------------------------

Line: 27

Test program for the MinLinq stuff. @author akarnokd

Line: 33

Utility class.

Line: 37

utility class

Line: 39

Run the observable with a print attached. @param observable the source observable @throws InterruptedException when the current thread is interrupted while waiting on the observable completion

Line: 49

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\TestInteractive0.java
---------------------------------------------------------------------------------

Line: 58

Test program for the MinLinq stuff. @author akarnokd

Line: 64

Utility class.

Line: 68

utility class

Line: 70

Run the Iterable with a print attached. @param source the iterable source waiting on the observable completion

Line: 85

@param args no arguments @throws Exception on error

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\TestObserveOn.java
------------------------------------------------------------------------------

Line: 22

@author akarnokd, 2011.01.29.

Line: 27

Test class.

Line: 33

@param args no arguments @throws Exception ignored

Line: 44

exec.shutdown();

Line: 45

exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MICROSECONDS);

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\test\ThrottleDemo.java
-----------------------------------------------------------------------------

Line: 39

A simple demonstration application how to start processing once the user stopped or paused typing for a specific time. @author akarnokd, 2011.02.01.

Line: 46

Construct the GUI.

Line: 90

dl.register(Observables.println("DL: "));

Line: 106

Observable<String> takeuntil = Observables.takeUntil(throttle, dl);

Line: 107

takeuntil.register(Observables.println("TAKEUNTIL: "));

Line: 125

Main program. @param args no arguments

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\ActionObservable.java
---------------------------------------------------------------------------------

Line: 27

The functional observable helper class with the anamorphism, bind and catamorpism basic operators. Inspired by http://blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx @author akarnokd

Line: 29

blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx

Line: 33

Helper class.

Line: 35

helper class.

Line: 37

Returns an action to an action to receive an option of T. @param <T> the type of the value (irrelevant) @return the action to action to option

Line: 50

Returns an action which takes an action which takes an option of T. @param <T> the type of the value @param value the value to return @return the action to action to option of T

Line: 65

The binding option to convert a source stream of Ts into streaming Rs. @param <T> the source type @param <R> the converted type @param source the source of Ts @param selector the selector which converts Ts to Rs. @return the action to action that receives option of R

Line: 97

Anamorphism that creates Ts starting from the seed value until the condition holds. Its equivalent is a for loop: for (int i = 0; i &lt; 10; i++) @param <T> the type of the values to generate @param seed the initial value @param condition the condition until the Ts should be produced @param next the way of compute the next T @return the function of founction of option of T

Line: 117

The action of action of option of none provider implemented by using anamorphism. @param <T> the type of the value (irrelevant) @return the action to action to option

Line: 126

The action of action of option of only a single element provider implemented by using anamorphism. @param <T> the value type @param value the value to return only once @return the action to action to option of T

Line: 146

A catamorphism which creates a single R out of the sequence of Ts by using an aggregator. The method is a greedy operation: it must wait all source values to arrive, therefore, do not use it on infinite sources. @param <T> the type of the sequence values @param <R> the output type @param source the source of the sequence values @param seed the initial value of the aggregation (e.g., start from zero) @param aggregator the aggregator function which takes a sequence value and the previous output value and produces a new output value @return the aggregation result

Line: 159

Indicate the aggregation end.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\DefaultEdtScheduler.java
------------------------------------------------------------------------------------

Line: 29

The default Event Dispatch Thread scheduler implementation. Which ensures that all tasks submittet to it will run on the EDT. @author akarnokd, 2011.02.02.

Line: 36

Helper class that has semantics for cancellation. @author akarnokd, 2011.02.02.

Line: 41

The wrapped runnable.

Line: 43

Should the run() method still execute its body?

Line: 45

Constructor. @param run the runnable

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\DefaultScheduler.java
---------------------------------------------------------------------------------

Line: 33

The default implementation of the Scheduler interface used by the Observables methods. @author akarnokd, 2011.02.02.

Line: 39

The common observable pool where the Observer methods get invoked by default.

Line: 41

The defalt scheduler pool for delayed observable actions.

Line: 43

Creates two separate pools for the immediate and scheduled executions. <ul> <li>ThreadPoolExecutor, having <ul> <li><code>Runtime.getRuntime().availableProcessors()</code> core thread</li> <li>1 second idle timeout</li> <li>core threads may timeout</li> <li>unbounded worker queue</li> <li>no rejection handler</li> </ul> </li> <li>ScheduledThreadPoolExecutor <ul> <li><code>Runtime.getRuntime().availableProcessors()</code> core thread</li> <li>1 second idle timeout</li> <li>core threads may timeout</li> <li>unbounded worker queue</li> <li>no rejection handler</li> <li>if running on Java 7 or above: remove on cancel policy set to true</li> </ul></li> </ul>

Line: 75

the setRemoveOnCancelPolicy() was introduced in Java 7 to allow the option to remove tasks from work queue if its initial delay hasn't elapsed -> therfore, if no other tasks are present, the scheduler might go idle earlier instead of waiting for the initial delay to pass to discover there is nothing to do. Because the library is currenlty aimed at Java 6, we use a reflection to set this policy on a Java 7 runtime.

Line: 96

Creates a default scheduler with the defined normal and scheduled pools. Note that since ScheduledExecutorService implements ExecutorService, you may pass in the same ScheduledExecutorService instance to fulfill both purposes. @param exec the executor service @param scheduled the scheduled executor service

Line: 113

Creates a default scheduler with the defined normal service and a default scheduled executor service. <ul> <li>ScheduledThreadPoolExecutor <ul> <li>1 core thread</li> <li>1 second idle timeout</li> <li>core threads may timeout</li> <li>unbounded worker queue</li> <li>no rejection handler</li> <li>if running on Java 7 or above: remove on cancel policy set to true</li> </ul></li> </ul> Note that since ScheduledExecutorService implements ExecutorService, you may pass in the a ScheduledExecutorService instance to fulfill both purposes. @param exec the executor service

Line: 140

the setRemoveOnCancelPolicy() was introduced in Java 7 to allow the option to remove tasks from work queue if its initial delay hasn't elapsed -> therfore, if no other tasks are present, the scheduler might go idle earlier instead of waiting for the initial delay to pass to discover there is nothing to do. Because the library is currenlty aimed at Java 6, we use a reflection to set this policy on a Java 7 runtime.

Line: 160

Creates a default scheduler with the defined scheduled pools and the default executor service. <ul> <li>ThreadPoolExecutor, having <ul> <li>1 core thread</li> <li>1 second idle timeout</li> <li>core threads may timeout</li> <li>unbounded worker queue</li> <li>no rejection handler</li> </ul> </li> </ul> Note that since ScheduledExecutorService implements ExecutorService, you may pass in the same ScheduledExecutorService instance to fulfill both purpose. @param scheduled the scheduled executor service

Line: 187

Helper class which invokes <code>Future.cancel(true)</code> on the wrapped future. @author akarnokd, 2011.02.02.

Line: 193

The wrapped future.

Line: 195

Constructor. @param future the future to close

Line: 224

Shutdown both pools.

Line: 231

Shutdown both pools now. @return the list of runnable tasks awaiting executions in both pools

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\EdtExecutorService.java
-----------------------------------------------------------------------------------

Line: 34

The wrapper for the event dispatch thread. @author akarnokd, 2011.01.28.

Line: 40

The syncron pool to call invokeAndWait() on EDT in sequence.

Line: 44

TODO Auto-generated method stub

Line: 79

Creates a wrapper callable task which invokes the original task in the EDT and waits for its completion, then forwards any result or exception as its own. @param <T> the result type @param task the original task @return the wrapper callable

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\FunctionIterable.java
---------------------------------------------------------------------------------

Line: 28

The functional iterable support with anamorphism, bind and catamorphism. http://blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx @author akarnokd

Line: 30

blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx

Line: 34

Utility class.

Line: 36

utility class

Line: 38

Returns a function of function that returns an empty option. @param <T> the type of the value (irrelevant) @return the function of function of option

Line: 56

Returns a fuction of function that returns the single value presented. @param <T> the type of the value @param value the single value to return @return the function of function of option of something

Line: 80

The generic binding operator to convert a source of Ts into a Rs. @param <T> the source element type @param <R> the output element type @param source the source creator @param selector the selector to produce Rs out of Ts. @return a function to function to option of R.

Line: 94

The source of Ts.

Line: 96

The last option of T we got.

Line: 98

The last R we produced.

Line: 100

The source of Rs.

Line: 126

Anamorphism that creates Ts starting from the seed value until the condition holds. Its equivalent is a for loop: for (int i = 0; i &lt; 10; i++) @param <T> the type of the values to generate @param seed the initial value @param condition the condition until the Ts should be produced @param next the way of compute the next T @return the function of founction of option of T

Line: 140

Current value.

Line: 151

The empty operator expressed by using the anamorphism. @param <T> the type of the value (irrelevant) @return the function of function of option of T

Line: 157

type inference issues

Line: 160

The single operator expressed by using anamorphism. @param <T> the type of the value @param value the value to return once @return the function of function of option T

Line: 167

type inference issues

Line: 169

Return true only once.

Line: 181

A catamorphism which creates a single R out of the sequence of Ts by using an aggregator. The method is a greedy operation: it must wait all source values to arrive, therefore, do not use it on infinite sources. @param <T> the type of the sequence values @param <R> the output type @param source the source of the sequence values @param seed the initial value of the aggregation (e.g., start from zero) @param aggregator the aggregator function which takes a sequence value and the previous output value and produces a new output value @return the aggregation result

Line: 201

Convert a regular iterable instance into a functional-iterable format. @param <T> the type of the iterable @param iterable the iterable object @return the function of function of option of T

Line: 212

The iterator.

Line: 222

Convert the submitted array into a functional-iterable format. @param <T> the array element type @param array the array of elements @return the function of function of option of T

Line: 245

Convert a function of function of option of T into a simple iterable object. @param <T> the type of the values @param source the source of the values @return the iterable of the values

Line: 256

The value source.

Line: 258

The peek value due hasNext.

Line: 260

Indicator if there was a hasNext() call before the next() call.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\package-info.java
-----------------------------------------------------------------------------

Line: 17

This package contain utility classes for various {@code Scheduler} implementations and two minimalist utility classes that work with {@code Func1} and {@code Action1} classes.

File: ..\Reactive4Java\src\hu\akarnokd\reactive4java\util\SingleLaneExecutor.java
-----------------------------------------------------------------------------------

Line: 32

A helper class which ensures that each of its queued elements get processed in sequence even on a multi-threaded pool. The class implements Closeable which may be called to cancel any on-going processing and remove any queued tasks. @author akarnokd, 2011.01.31. @param <T> the element type to process

Line: 41

The executor pool.

Line: 43

Keeps track of the queue size.

Line: 45

The queue of items.

Line: 47

The action to invoke for each element.

Line: 49

The queue processor.

Line: 52

ensure that only one instance is running

Line: 68

The future of the currently running processor.

Line: 70

Constructor. @param pool the executor service to use as the pool. @param action the action to invoke when processing a queue item

Line: 85

Add an item to the queue and start the processor if necessary. @param item the item to add.

Line: 97

Add the iterable series of items. The items are added via add() method, and might start the processor if necessary. @param items the iterable of items

Line: 113

drain remaining elements as of now

